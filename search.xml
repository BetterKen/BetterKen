<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8.MysqlExplain介绍</title>
      <link href="/2020/02/16/8-MysqlExplain%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/02/16/8-MysqlExplain%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="8-1-Explain各列意义"><a href="#8-1-Explain各列意义" class="headerlink" title="8.1 Explain各列意义"></a>8.1 Explain各列意义</h2><p>EXPLAIN 命令的输出内容大致如下:</p><pre><code class="mysql">mysql&gt; explain select *  from t_scrm_user_info where bigdata_user_id &gt; &#39;A1001036&#39; and bigdata_user_id &lt; &#39;A2100000&#39;\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_user_info   partitions: NULL         type: rangepossible_keys: UQ_CUSTOMER_ID          key: UQ_CUSTOMER_ID      key_len: 130          ref: NULL         rows: 168902     filtered: 100.00        Extra: Using index condition1 row in set, 1 warning (0.00 sec)</code></pre><table><thead><tr><th align="center">列名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</td></tr><tr><td align="center">select_type</td><td align="center">SELECT 查询的类型.</td></tr><tr><td align="center">table</td><td align="center">查询的是哪个表</td></tr><tr><td align="center">partitions</td><td align="center">匹配的分区</td></tr><tr><td align="center">type</td><td align="center">join 类型</td></tr><tr><td align="center">possible_keys</td><td align="center">此次查询中可能选用的索引</td></tr><tr><td align="center">key</td><td align="center">此次查询中确切使用到的索引.</td></tr><tr><td align="center">ref</td><td align="center">哪个字段或常数与 key 一起被使用</td></tr><tr><td align="center">rows</td><td align="center">显示此查询一共扫描了多少行. 这个是一个估计值.</td></tr><tr><td align="center">filtered</td><td align="center">表示此查询条件所过滤的数据的百分比</td></tr><tr><td align="center">extra</td><td align="center">额外的信息</td></tr></tbody></table><h2 id="8-2-id"><a href="#8-2-id" class="headerlink" title="8.2 id"></a>8.2 id</h2><p>表示select标识符，同时表明执行顺序，也就是说id是一个查询的序列号，查询序号即为sql语句执行的顺序。</p><ol><li>当id值相同时，按从上到下的顺序执行</li><li>当id全部不同时，按id从大到小执行</li><li>当id部分不同时，先执行id大的，id相同的，按从上到下的顺序执行</li></ol><h2 id="8-3-select-type"><a href="#8-3-select-type" class="headerlink" title="8.3 select_type"></a>8.3 select_type</h2><ol><li>SIMPLE 简单的select查询，查询中不包含子查询或者UNION</li><li>PRIMARY 查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY</li><li>SUBQUERY 在SELECT或WHERE列表中包含了子查询</li><li>DERIVED 在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放在临时表中</li><li>UNION 若第二个SELECT出现在UNION之后，则被标记为UNION：若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED</li><li>UNION RESULT 从UNION表获取结果的SELECT</li></ol><pre><code class="mysql">mysql&gt; explain select * from t_scrm_user_info where  id = 1\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_user_info   partitions: NULL         type: constpossible_keys: PRIMARY,IX_ID_CREATE_TIME          key: PRIMARY      key_len: 4          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)ERROR: No query specified==================================================================================mysql&gt; explain select * from (select * from t_scrm_pet_info limit 20) t where  t.id = (select id from t_scrm_map limit 1)\G;*************************** 1. row ***************************           id: 1  select_type: PRIMARY        table: &lt;derived2&gt;   partitions: NULL         type: refpossible_keys: &lt;auto_key0&gt;          key: &lt;auto_key0&gt;      key_len: 4          ref: const         rows: 2     filtered: 100.00        Extra: Using where*************************** 2. row ***************************           id: 3  select_type: SUBQUERY        table: t_scrm_map   partitions: NULL         type: indexpossible_keys: NULL          key: IX_CREATE_TIME      key_len: 5          ref: NULL         rows: 11271619     filtered: 100.00        Extra: Using index*************************** 3. row ***************************           id: 2  select_type: DERIVED        table: t_scrm_pet_info   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 4578062     filtered: 100.00        Extra: NULL3 rows in set, 1 warning (0.00 sec)ERROR: No query specified==================================================================================mysql&gt; explain select * from t_scrm_map where id =10 union select * from t_scrm_map where id = 20\G;*************************** 1. row ***************************           id: 1  select_type: PRIMARY        table: t_scrm_map   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 4          ref: const         rows: 1     filtered: 100.00        Extra: NULL*************************** 2. row ***************************           id: 2  select_type: UNION        table: t_scrm_map   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 4          ref: const         rows: 1     filtered: 100.00        Extra: NULL*************************** 3. row ***************************           id: NULL  select_type: UNION RESULT        table: &lt;union1,2&gt;   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: NULL     filtered: NULL        Extra: Using temporary3 rows in set, 1 warning (0.00 sec)</code></pre><h2 id="8-4-table"><a href="#8-4-table" class="headerlink" title="8.4 table"></a>8.4 table</h2><p>这一列表示 explain 的一行正在访问哪个表。</p><p>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。当有 union 时，UNION RESULT 的 table 列的值为 &lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p><h2 id="8-5-partitions"><a href="#8-5-partitions" class="headerlink" title="8.5 partitions"></a>8.5 partitions</h2><p>使用的哪些分区（对于非分区表值为null）</p><h2 id="8-6-type"><a href="#8-6-type" class="headerlink" title="8.6 type"></a>8.6 type</h2><p>type所显示的是查询使用了哪种类型，type包含的类型包括如下图所示的几种：</p><p>从最好到最差依次是：</p><pre><code>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</code></pre><p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p><ul><li><code>const, system</code>：mysql能对查询的某部分进行优化并将其转化成一个常量。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。</li></ul><pre><code class="mysql">mysql&gt; explain select * from t_scrm_user_info where bigdata_user_id = &#39;B13470427&#39;\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_user_info   partitions: NULL         type: constpossible_keys: UQ_CUSTOMER_ID          key: UQ_CUSTOMER_ID      key_len: 130          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>eq_ref</code>：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的<code>联接类型</code>了，简单的 select 查询不会出现这种 type。</li></ul><pre><code class="mysql">mysql&gt; explain select * from t_scrm_user_info u left join t_scrm_map m on u.bigdata_user_id = m.bigdata_id where u.bigdata_user_id = &#39;B13470427&#39;\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: u   partitions: NULL         type: constpossible_keys: UQ_CUSTOMER_ID          key: UQ_CUSTOMER_ID      key_len: 130          ref: const         rows: 1     filtered: 100.00        Extra: NULL*************************** 2. row ***************************           id: 1  select_type: SIMPLE        table: m   partitions: NULL         type: refpossible_keys: UQ_ID          key: UQ_ID      key_len: 258          ref: const         rows: 1     filtered: 100.00        Extra: Using where2 rows in set, 1 warning (0.00 sec)</code></pre><ul><li>ref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</li></ul><pre><code class="mysql">mysql&gt; explain select * from t_scrm_map where target_id = &#39;11255964&#39;\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_map   partitions: NULL         type: refpossible_keys: IX_TRAGET_ID          key: IX_TRAGET_ID      key_len: 130          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>ref_or_null</code>：类似ref，但是可以搜索值为NULL的行。</li><li><code>range</code>：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</li></ul><pre><code class="mysql">mysql&gt; explain select * from t_scrm_map where id &gt; 10 and id  &lt;20\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_map   partitions: NULL         type: rangepossible_keys: PRIMARY          key: PRIMARY      key_len: 4          ref: NULL         rows: 9     filtered: 100.00        Extra: Using where1 row in set, 1 warning (0.00 sec)ERROR: No query specified</code></pre><ul><li><code>index</code>：和ALL一样，不同就是mysql只需扫描索引树，这通常比ALL快一些。</li></ul><pre><code class="mysql">mysql&gt; explain select count(*) from t_scrm_map\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_map   partitions: NULL         type: indexpossible_keys: NULL          key: IX_CREATE_TIME      key_len: 5          ref: NULL         rows: 11271619     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)ERROR: No query specified</code></pre><ul><li><code>ALL</code>：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了</li></ul><pre><code class="mysql">mysql&gt; explain select * from t_scrm_map\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_map   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 11271619     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)ERROR: No query specified</code></pre><h2 id="8-7-possible-keys"><a href="#8-7-possible-keys" class="headerlink" title="8.7  possible_keys"></a>8.7  possible_keys</h2><p>这一列显示查询可能使用哪些索引来查找。 </p><p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 </p><p>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p><h2 id="8-8-key"><a href="#8-8-key" class="headerlink" title="8.8 key"></a>8.8 key</h2><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。</p><p>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p><h2 id="8-9-key-len列"><a href="#8-9-key-len列" class="headerlink" title="8.9 key_len列"></a>8.9 key_len列</h2><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 </p><pre><code class="mysql">key_len 的计算规则如下:字符串char(n): n 字节长度varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4n +2 字节.数值类型:TINYINT: 1字节SMALLINT: 2字节MEDIUMINT: 3字节INT: 4字节BIGINT: 8字节时间类型DATE: 3字节TIMESTAMP: 4字节DATETIME: 8字节字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</code></pre><pre><code class="mysql">mysql&gt; explain select count(*) from t_scrm_map where target_id  = &#39;11255964&#39;\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_map   partitions: NULL         type: refpossible_keys: IX_TRAGET_ID          key: IX_TRAGET_ID      key_len: 130          ref: const         rows: 1     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)/**| t_scrm_map | CREATE TABLE `t_scrm_map` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  `bigdata_id` varchar(64) NOT NULL COMMENT &#39;唯一ID&#39;,  `type` tinyint(3) NOT NULL COMMENT &#39;关联类型&#39;,  PRIMARY KEY (`id`),  UNIQUE KEY `UQ_ID` (`bigdata_id`,`type`),  KEY `IX_MAP_ID` (`scrm_id`),) ENGINE=InnoDB AUTO_INCREMENT=11962156 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT=&#39;关系表&#39; |*/mysql&gt; explain select count(*) from t_scrm_map where bigdata_id  = &#39;11255964&#39;\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_map   partitions: NULL         type: refpossible_keys: UQ_ID          key: UQ_ID      key_len: 258          ref: const         rows: 1     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.04 sec)可以看到key_len = 258---&gt; 64*4+2;即只使用了索引UQ_ID的bigdata_id部分mysql&gt; explain select * from t_scrm_map where bigdata_id  = &#39;B11255964&#39; and type = 1\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_map   partitions: NULL         type: constpossible_keys: UQ_ID          key: UQ_ID      key_len: 259          ref: const,const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.04 sec)可以看到key_len = 258---&gt; 64*4+2+1;即使用了索引UQ_ID的bigdata_id和type部分</code></pre><h2 id="8-10-ref列"><a href="#8-10-ref列" class="headerlink" title="8.10 ref列"></a>8.10 ref列</h2><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：</p><ul><li><p>const（常量）</p></li><li><p>func</p></li><li><p>NULL</p></li><li><p>字段名</p></li></ul><h2 id="8-11-rows列rows"><a href="#8-11-rows列rows" class="headerlink" title="8.11 rows列rows"></a>8.11 rows列rows</h2><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数. 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p><h2 id="8-12-Extra列"><a href="#8-12-Extra列" class="headerlink" title="8.12 Extra列"></a>8.12 Extra列</h2><p>这一列展示的是额外信息。常见的重要值如下： </p><h3 id="8-12-1-Using-filesort"><a href="#8-12-1-Using-filesort" class="headerlink" title="8.12.1 Using filesort"></a>8.12.1 Using filesort</h3><p>mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。</p><p><code>这种情况是要考虑使用索引来优化的</code></p><pre><code class="mysql">mysql&gt; explain select * from t_scrm_map order by type asc\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_map   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 11271619     filtered: 100.00        Extra: Using filesort1 row in set, 1 warning (0.00 sec)</code></pre><h3 id="8-12-2-Using-temporary"><a href="#8-12-2-Using-temporary" class="headerlink" title="8.12.2 Using temporary"></a>8.12.2 Using temporary</h3><p>使用临时表保存中间结果，常用于GROUP BY 和 ORDER BY,DISTINCT操作中。</p><p>出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p><pre><code class="mysql">mysql&gt; explain select distinct(type) from t_scrm_map order by type asc\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_map   partitions: NULL         type: indexpossible_keys: UQ_ID          key: UQ_ID      key_len: 259          ref: NULL         rows: 11271619     filtered: 100.00        Extra: Using index; Using temporary; Using filesort1 row in set, 1 warning (0.00 sec)</code></pre><h3 id="8-12-3-Using-where"><a href="#8-12-3-Using-where" class="headerlink" title="8.12.3 Using where"></a>8.12.3 Using where</h3><p>在查找使用索引的情况下，需要回表去查询所需的数据</p><pre><code class="mysql">mysql&gt; explain select * from t_scrm_map where target_id  = &#39;11255964&#39; and type =2\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_map   partitions: NULL         type: refpossible_keys: IX_TRAGET_ID          key: IX_TRAGET_ID      key_len: 130          ref: const         rows: 1     filtered: 10.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><h3 id="8-12-4-Using-index"><a href="#8-12-4-Using-index" class="headerlink" title="8.12.4 Using index"></a>8.12.4 Using index</h3><p>这发生在对表的请求列都是同一索引的部分的时候，返回的列数据只使用了索引中的信息，而没有再去访问表中的行记录。是性能高的表现。</p><pre><code class="mysql">mysql&gt; explain select count(*) from t_scrm_map\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_map   partitions: NULL         type: indexpossible_keys: NULL          key: IX_CREATE_TIME      key_len: 5          ref: NULL         rows: 11271619     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><h3 id="8-12-5-Using-index-condition"><a href="#8-12-5-Using-index-condition" class="headerlink" title="8.12.5 Using index condition"></a>8.12.5 Using index condition</h3><p>这是MySQL 5.6出来的新特性，叫做“索引条件推送”。</p><p>简单说一点就是MySQL原来在索引上是不能执行如like这样的操作的，但是现在可以了，这样减少了不必要的IO操作，但是只能用在二级索引上。</p><pre><code class="mysql">mysql&gt; explain select * from t_scrm_map where bigdata_id  = &#39;B11255964&#39; or bigdata_id like &#39;B125294%&#39;\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_map   partitions: NULL         type: rangepossible_keys: UQ_ID          key: UQ_ID      key_len: 258          ref: NULL         rows: 8     filtered: 100.00        Extra: Using index condition1 row in set, 1 warning (0.00 sec)</code></pre><h3 id="8-12-6-Using-join-buffer"><a href="#8-12-6-Using-join-buffer" class="headerlink" title="8.12.6 Using join buffer"></a>8.12.6 Using join buffer</h3><p>使用了连接缓存：</p><ul><li>Block Nested Loop，连接算法是块嵌套循环连接;</li><li>Batched Key Access，连接算法是批量索引连接</li></ul><h3 id="8-12-7-Using-MRR"><a href="#8-12-7-Using-MRR" class="headerlink" title="8.12.7 Using MRR"></a>8.12.7 Using MRR</h3><p>使用了MRR优化算法</p><pre><code class="mysql">mysql&gt; explain select *  from t_scrm_user_info where bigdata_user_id &gt; &#39;A1001036&#39; and bigdata_user_id &lt; &#39;A2100000&#39;\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: t_scrm_user_info   partitions: NULL         type: rangepossible_keys: UQ_CUSTOMER_ID          key: UQ_CUSTOMER_ID      key_len: 130          ref: NULL         rows: 168902     filtered: 100.00        Extra: Using index condition; Using MRR1 row in set, 1 warning (0.00 sec)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.MysqlProfile介绍</title>
      <link href="/2020/02/16/9-MysqlProfile%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/02/16/9-MysqlProfile%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="9-1-相关参数"><a href="#9-1-相关参数" class="headerlink" title="9.1　相关参数"></a>9.1　相关参数</h2><pre><code class="mysql">mysql&gt; show variables like &#39;%profil%&#39;;+------------------------+-------+| Variable_name          | Value |+------------------------+-------+| have_profiling         | YES   || profiling              | OFF   || profiling_history_size | 15    |+------------------------+-------+3 rows in set (0.01 sec)have_profiling： 当前版本是否支持profiling功能profiling： 是否开启profiling功能profiling_history_size： 保留profiling的数目，默认是15，范围为0~100，为0时代表禁用profiling</code></pre><h2 id="9-2-开启profile"><a href="#9-2-开启profile" class="headerlink" title="9.2 开启profile"></a>9.2 开启profile</h2><pre><code class="mysql">session级别开启:mysql&gt; SET profiling = 1;全局开启echo &quot;profiling=1&quot; &gt;&gt; my.cnf</code></pre><h2 id="9-3-help-profile"><a href="#9-3-help-profile" class="headerlink" title="9.3 help profile"></a>9.3 help profile</h2><p>我们可以通过help profile查看profile的用法,官方的解释已经很好了</p><pre><code class="mysql">mysql&gt; help profile;Name: &#39;SHOW PROFILE&#39;Description:Syntax:SHOW PROFILE [type [, type] ... ]    [FOR QUERY n]    [LIMIT row_count [OFFSET offset]]type: {    ALL  | BLOCK IO  | CONTEXT SWITCHES  | CPU  | IPC  | MEMORY  | PAGE FAULTS  | SOURCE  | SWAPS}The SHOW PROFILE and SHOW PROFILES statements display profilinginformation that indicates resource usage for statements executedduring the course of the current session.*Note*:The SHOW PROFILE and SHOW PROFILES statements are deprecated and willbe removed in a future MySQL release. Use the Performance Schemainstead; seehttp://dev.mysql.com/doc/refman/5.7/en/performance-schema-query-profiling.html.To control profiling, use the profiling session variable, which has adefault value of 0 (OFF). Enable profiling by setting profiling to 1 orON:mysql&gt; SET profiling = 1;SHOW PROFILES displays a list of the most recent statements sent to theserver. The size of the list is controlled by theprofiling_history_size session variable, which has a default value of15. The maximum value is 100. Setting the value to 0 has the practicaleffect of disabling profiling.All statements are profiled except SHOW PROFILE and SHOW PROFILES, soyou will find neither of those statements in the profile list.Malformed statements are profiled. For example, SHOW PROFILING is anillegal statement, and a syntax error occurs if you try to execute it,but it will show up in the profiling list.SHOW PROFILE displays detailed information about a single statement.Without the FOR QUERY n clause, the output pertains to the mostrecently executed statement. If FOR QUERY n is included, SHOW PROFILEdisplays information for statement n. The values of n correspond to theQuery_ID values displayed by SHOW PROFILES.The LIMIT row_count clause may be given to limit the output torow_count rows. If LIMIT is given, OFFSET offset may be added to beginthe output offset rows into the full set of rows.By default, SHOW PROFILE displays Status and Duration columns. TheStatus values are like the State values displayed by SHOW PROCESSLIST,although there might be some minor differences in interpretion for thetwo statements for some status values (seehttp://dev.mysql.com/doc/refman/5.7/en/thread-information.html).Optional type values may be specified to display specific additionaltypes of information:o ALL displays all informationo BLOCK IO displays counts for block input and output operationso CONTEXT SWITCHES displays counts for voluntary and involuntary  context switcheso CPU displays user and system CPU usage timeso IPC displays counts for messages sent and receivedo MEMORY is not currently implementedo PAGE FAULTS displays counts for major and minor page faultso SOURCE displays the names of functions from the source code, together  with the name and line number of the file in which the function  occurso SWAPS displays swap countsProfiling is enabled per session. When a session ends, its profilinginformation is lost.URL: http://dev.mysql.com/doc/refman/5.7/en/show-profile.htmlExamples:mysql&gt; SELECT @@profiling;+-------------+| @@profiling |+-------------+|           0 |+-------------+1 row in set (0.00 sec)mysql&gt; SET profiling = 1;Query OK, 0 rows affected (0.00 sec)mysql&gt; DROP TABLE IF EXISTS t1;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; CREATE TABLE T1 (id INT);Query OK, 0 rows affected (0.01 sec)mysql&gt; SHOW PROFILES;+----------+----------+--------------------------+| Query_ID | Duration | Query                    |+----------+----------+--------------------------+|        0 | 0.000088 | SET PROFILING = 1        ||        1 | 0.000136 | DROP TABLE IF EXISTS t1  ||        2 | 0.011947 | CREATE TABLE t1 (id INT) |+----------+----------+--------------------------+3 rows in set (0.00 sec)mysql&gt; SHOW PROFILE;+----------------------+----------+| Status               | Duration |+----------------------+----------+| checking permissions | 0.000040 || creating table       | 0.000056 || After create         | 0.011363 || query end            | 0.000375 || freeing items        | 0.000089 || logging slow query   | 0.000019 || cleaning up          | 0.000005 |+----------------------+----------+7 rows in set (0.00 sec)mysql&gt; SHOW PROFILE FOR QUERY 1;+--------------------+----------+| Status             | Duration |+--------------------+----------+| query end          | 0.000107 || freeing items      | 0.000008 || logging slow query | 0.000015 || cleaning up        | 0.000006 |+--------------------+----------+4 rows in set (0.00 sec)mysql&gt; SHOW PROFILE CPU FOR QUERY 2;+----------------------+----------+----------+------------+| Status               | Duration | CPU_user | CPU_system |+----------------------+----------+----------+------------+| checking permissions | 0.000040 | 0.000038 |   0.000002 || creating table       | 0.000056 | 0.000028 |   0.000028 || After create         | 0.011363 | 0.000217 |   0.001571 || query end            | 0.000375 | 0.000013 |   0.000028 || freeing items        | 0.000089 | 0.000010 |   0.000014 || logging slow query   | 0.000019 | 0.000009 |   0.000010 || cleaning up          | 0.000005 | 0.000003 |   0.000002 |+----------------------+----------+----------+------------+7 rows in set (0.00 sec)</code></pre><h2 id="9-4-type类型"><a href="#9-4-type类型" class="headerlink" title="9.4 type类型"></a>9.4 type类型</h2><p>这里我们主要关注两个指标　</p><ul><li><code>ALL</code>:显示所性能信息</li><li><code>BLOCK IO</code>:显示块(页)IO的数量<ul><li>BLOCK_OPS_IN:输入页数量</li><li>BLOCK_OPS_OUT:输出页数量</li></ul></li><li><code>CONTEXT SWITCHES</code>:上下文切换相关开销</li><li><code>CPU</code>:显示CPU相关开销信息<ul><li>CPU_user:用户所用时间,秒单位 </li><li>CPU_system:系统所用时间,秒单位 </li></ul></li><li><code>IPC</code>:显示发送和接收相关开销信息</li><li><code>MEMORY</code>:显示内存相关开销信息</li><li><code>PAGE FAULTS</code> :显示页面错误相关开销信息</li><li><code>SOURCE</code> :显示和Source_function，Source_file，Source_line相关的开销信息</li><li><code>SWAPS</code> :显示交换次数相关开销的信息</li></ul><h2 id="9-5-profile过程"><a href="#9-5-profile过程" class="headerlink" title="9.5 profile过程"></a>9.5 profile过程</h2><pre><code class="mysql">mysql&gt; show profile for query 4;+----------------------+-----------+| Status               | Duration  |+----------------------+-----------+| starting             |  0.000083 || checking permissions |  0.000013 || Opening tables       |  0.000019 || init                 |  0.000036 || System lock          |  0.000014 || optimizing           |  0.000012 || statistics           |  0.000021 || preparing            |  0.000018 || executing            |  0.000006 || Sending data         | 87.327560 || end                  |  0.000016 || query end            |  0.000013 || closing tables       |  0.000011 || freeing items        |  0.000027 || logging slow query   |  0.000057 || cleaning up          |  0.000017 |+----------------------+-----------+16 rows in set, 1 warning (0.00 sec)starting：开始checking permissions：检查权限Opening tables：打开表init ： 初始化System lock ：系统锁optimizing ： 优化statistics ： 统计preparing ：准备executing ：执行Sending data ：发送数据Sorting result ：排序end ：结束query end ：查询 结束closing tables ： 关闭表 ／去除TMP 表freeing items ： 释放事件cleaning up ：清理profile只能列出使用到的环节　没有使用的环节不显示</code></pre><h3 id="9-5-1-重点环节"><a href="#9-5-1-重点环节" class="headerlink" title="9.5.1 重点环节"></a>9.5.1 重点环节</h3><ul><li><code>preparing</code> ：准备</li><li><code>executing</code> ：执行</li><li><code>Sending data</code> ：发送数据  一般这个环节时间最长</li><li><code>Sorting result</code> ：排序</li></ul><h3 id="9-5-2-不应-减少出现的环节"><a href="#9-5-2-不应-减少出现的环节" class="headerlink" title="9.5.2 不应/减少出现的环节"></a>9.5.2 不应/减少出现的环节</h3><ul><li><code>converting HEAP to MyISAM</code>： 查询结果太大，内存都不够用了，往磁盘上搬了</li><li><code>creating tmp table</code> ：创建临时表，拷贝数据到临时表，然后再删除</li><li><code>copying to tmp table on disk</code> ：把内存中临时表复制到磁盘</li><li><code>locked</code>: 被锁喉了~</li></ul><h2 id="9-6-日常常用指令"><a href="#9-6-日常常用指令" class="headerlink" title="9.6 日常常用指令"></a>9.6 日常常用指令</h2><pre><code class="mysql">SHOW PROFILE block io,cpu FOR QUERY N;多注意CPU和IOmysql&gt; SHOW PROFILE block io,cpu FOR QUERY 4\G;*************************** 1. row ***************************       Status: starting     Duration: 0.000083     CPU_user: 0.000049   CPU_system: 0.000025 Block_ops_in: 0Block_ops_out: 0*************************** 2. row ***************************       Status: checking permissions     Duration: 0.000013     CPU_user: 0.000006   CPU_system: 0.000003 Block_ops_in: 0Block_ops_out: 0*************************** 3. row ***************************       Status: Opening tables     Duration: 0.000019     CPU_user: 0.000012   CPU_system: 0.000006 Block_ops_in: 0Block_ops_out: 0*************************** 4. row ***************************       Status: init     Duration: 0.000036     CPU_user: 0.000022   CPU_system: 0.000012 Block_ops_in: 0Block_ops_out: 0*************************** 5. row ***************************       Status: System lock     Duration: 0.000014     CPU_user: 0.000008   CPU_system: 0.000004 Block_ops_in: 0Block_ops_out: 0*************************** 6. row ***************************       Status: optimizing     Duration: 0.000012     CPU_user: 0.000007   CPU_system: 0.000003 Block_ops_in: 0Block_ops_out: 0*************************** 7. row ***************************       Status: statistics     Duration: 0.000021     CPU_user: 0.000013   CPU_system: 0.000007 Block_ops_in: 0Block_ops_out: 0*************************** 8. row ***************************       Status: preparing     Duration: 0.000018     CPU_user: 0.000011   CPU_system: 0.000006 Block_ops_in: 0Block_ops_out: 0*************************** 9. row ***************************       Status: executing     Duration: 0.000006     CPU_user: 0.000003   CPU_system: 0.000002 Block_ops_in: 0Block_ops_out: 0*************************** 10. row ***************************       Status: Sending data     Duration: 87.327560     CPU_user: 37.617680   CPU_system: 32.943640 Block_ops_in: 2591264Block_ops_out: 0*************************** 11. row ***************************       Status: end     Duration: 0.000016     CPU_user: 0.000006   CPU_system: 0.000004 Block_ops_in: 0Block_ops_out: 0*************************** 12. row ***************************       Status: query end     Duration: 0.000013     CPU_user: 0.000007   CPU_system: 0.000005 Block_ops_in: 0Block_ops_out: 0*************************** 13. row ***************************       Status: closing tables     Duration: 0.000011     CPU_user: 0.000006   CPU_system: 0.000004 Block_ops_in: 0Block_ops_out: 0*************************** 14. row ***************************       Status: freeing items     Duration: 0.000027     CPU_user: 0.000015   CPU_system: 0.000010 Block_ops_in: 0Block_ops_out: 0*************************** 15. row ***************************       Status: logging slow query     Duration: 0.000057     CPU_user: 0.000032   CPU_system: 0.000021 Block_ops_in: 0Block_ops_out: 8*************************** 16. row ***************************       Status: cleaning up     Duration: 0.000017     CPU_user: 0.000009   CPU_system: 0.000006 Block_ops_in: 0Block_ops_out: 016 rows in set, 1 warning (0.00 sec)ERROR: No query specified</code></pre><h2 id="9-7-使用Performance查看profi"><a href="#9-7-使用Performance查看profi" class="headerlink" title="9.7  使用Performance查看profi"></a>9.7  使用Performance查看profi</h2><p>通过help profile我们知道show proflie相关指令即将废弃,可以使用如下指令进行查询</p><p>在使用以下两个命令前需要做一些设置角色的操作:具体请参考官方文档:</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema-query-profiling.html" target="_blank" rel="noopener">25.19.1 Query Profiling Using Performance Schema</a></p><h3 id="9-7-1-查看所有语句"><a href="#9-7-1-查看所有语句" class="headerlink" title="9.7.1 查看所有语句"></a>9.7.1 查看所有语句</h3><pre><code class="mysql">mysql&gt; SELECT EVENT_ID, TRUNCATE(TIMER_WAIT/1000000000000,6) as Duration, SQL_TEXT        FROM performance_schema.events_statements_history_long\G;*************************** 1. row ***************************EVENT_ID: 146Duration: 0.000842SQL_TEXT: UPDATE performance_schema.setup_consumers       SET ENABLED = &#39;YES&#39;       WHERE NAME LIKE &#39;%events_statements_%&#39;*************************** 2. row ***************************EVENT_ID: 147Duration: 0.000376SQL_TEXT: UPDATE performance_schema.setup_consumers       SET ENABLED = &#39;YES&#39;       WHERE NAME LIKE &#39;%events_stages_%&#39;*************************** 3. row ***************************EVENT_ID: 154Duration: 2.089741SQL_TEXT: select count(*) from t_scrm_pet_info where pet_birthday &gt; &#39;2019-01-01 00:00:01&#39; and pet_birthday &lt; &#39;2019-03-01 00:00:01&#39;*************************** 4. row ***************************EVENT_ID: 171Duration: 0.003488SQL_TEXT: SELECT EVENT_ID, TRUNCATE(TIMER_WAIT/1000000000000,6) as Duration, SQL_TEXT       FROM performance_schema.events_statements_history_long*************************** 5. row ***************************EVENT_ID: 188Duration: 0.000899SQL_TEXT: SELECT event_name AS Stage, TRUNCATE(TIMER_WAIT/1000000000000,6) AS Duration       FROM performance_schema.events_stages_history_long WHERE NESTING_EVENT_ID=154*************************** 6. row ***************************EVENT_ID: 205Duration: 0.000480SQL_TEXT: SELECT event_name AS Stage, TRUNCATE(TIMER_WAIT/1000000000000,6) AS Duration        FROM performance_schema.events_stages_history_long WHERE NESTING_EVENT_ID=154*************************** 7. row ***************************EVENT_ID: 222Duration: 0.000669SQL_TEXT: SELECT EVENT_ID, TRUNCATE(TIMER_WAIT/1000000000000,6) as Duration, SQL_TEXT        FROM performance_schema.events_statements_history_long7 rows in set (0.00 sec)ERROR: No query specified</code></pre><h3 id="9-7-2-查看指定语句"><a href="#9-7-2-查看指定语句" class="headerlink" title="9.7.2 查看指定语句"></a>9.7.2 查看指定语句</h3><pre><code class="mysql">mysql&gt; SELECT event_name AS Stage, TRUNCATE(TIMER_WAIT/1000000000000,6) AS Duration        FROM performance_schema.events_stages_history_long WHERE NESTING_EVENT_ID=154\G;*************************** 1. row ***************************   Stage: stage/sql/startingDuration: 0.000105*************************** 2. row ***************************   Stage: stage/sql/checking permissionsDuration: 0.000008*************************** 3. row ***************************   Stage: stage/sql/Opening tablesDuration: 0.000021*************************** 4. row ***************************   Stage: stage/sql/initDuration: 0.000059*************************** 5. row ***************************   Stage: stage/sql/System lockDuration: 0.000016*************************** 6. row ***************************   Stage: stage/sql/optimizingDuration: 0.000014*************************** 7. row ***************************   Stage: stage/sql/statisticsDuration: 0.000023*************************** 8. row ***************************   Stage: stage/sql/preparingDuration: 0.000017*************************** 9. row ***************************   Stage: stage/sql/executingDuration: 0.000002*************************** 10. row ***************************   Stage: stage/sql/Sending dataDuration: 2.089357*************************** 11. row ***************************   Stage: stage/sql/endDuration: 0.000005*************************** 12. row ***************************   Stage: stage/sql/query endDuration: 0.000012*************************** 13. row ***************************   Stage: stage/sql/closing tablesDuration: 0.000009*************************** 14. row ***************************   Stage: stage/sql/freeing itemsDuration: 0.000027*************************** 15. row ***************************   Stage: stage/sql/logging slow queryDuration: 0.000055*************************** 16. row ***************************   Stage: stage/sql/cleaning upDuration: 0.00000116 rows in set (0.00 sec)ERROR: No query specified</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.Mysql优化器算法</title>
      <link href="/2020/02/16/7-Mysql%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/16/7-Mysql%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>除了我们自己手动进行优化外,根据之前的章节,我们可以知道,Mysql内部自己有优化器,对SQL语句进行一些内部的优化,本章介绍几个常用的优化算法:</p><ul><li>MRR</li><li>ICP</li><li>BKA</li></ul><h2 id="7-1-MRR"><a href="#7-1-MRR" class="headerlink" title="7.1 MRR"></a>7.1 MRR</h2><p>MRR——Multi Range Read</p><h3 id="7-1-1作用"><a href="#7-1-1作用" class="headerlink" title="7.1.1作用"></a>7.1.1作用</h3><p>减少磁盘的随机访问，并将随机访问转化为顺序的数据访问</p><h3 id="7-1-2-原理"><a href="#7-1-2-原理" class="headerlink" title="7.1.2 原理"></a>7.1.2 原理</h3><p>在不使用 MRR 时，优化器需要根据二级索引返回的记录来进行“回表”，这个过程一般会有较多的随机 IO, 使用 MRR 时，SQL 语句的执行过程是这样的：</p><ol><li>优化器将二级索引查询到的记录放到一块缓冲区中；</li><li>如果二级索引扫描到文件的末尾或者缓冲区已满，则使用<code>快速排序对缓冲区中的内容按照主键进行排序</code>；</li><li>用户线程调用 MRR 接口取 cluster index，然后根据cluster index 取行数据；</li><li>当根据缓冲区中的 cluster index 取完数据，则继续调用过程 2) 3)，直至扫描结束；</li></ol><p>通过上述过程，优化器将二级索引随机的 IO 进行排序，转化为主键的有序排列，从而实现了随机 IO 到顺序 IO 的转化，提升性能</p><p>在未开启MRR时,查询方式如图所示:</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/no-mrr-access-pattern.png" alt=""></p><p>开启MRR后,查询方式如下图所示:</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/mrr-access-pattern.png" alt=""></p><h3 id="7-1-3-开关MRR"><a href="#7-1-3-开关MRR" class="headerlink" title="7.1.3 开关MRR"></a>7.1.3 开关MRR</h3><p>我们可以通过 以下命令查看和开启MRR,5.6以后默认是开启的</p><pre><code class="mysql">查看MRR是否开启mysql&gt; select @@optimizer_switch\G*************************** 1. row ***************************@@optimizer_switch: index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on1 row in set (0.00 sec)注意上面的mrr=on关闭MRRmysql&gt; set optimizer_switch=&#39;mrr=off&#39;;开启MRRmysql&gt; set optimizer_switch=&#39;mrr=on&#39;;相关参数当mrr=on,mrr_cost_based=on，则表示cost base的方式还选择启用MRR优化,当发现优化后的代价过高时就会不使用该项优化当mrr=on,mrr_cost_based=off，则表示总是开启MRR优化尽量设置 mrr_cost_based=ON，毕竟大多数情况下优化器是对的</code></pre><h3 id="7-1-4-开关对比"><a href="#7-1-4-开关对比" class="headerlink" title="7.1.4 开关对比"></a>7.1.4 开关对比</h3><pre><code class="mysql">mysql&gt; explain select *  from t_scrm_user_info where bigdata_user_id &gt; &#39;A1001036&#39; and bigdata_user_id &lt; &#39;A2100000&#39;;</code></pre><p>当<code>mrr=off</code>时</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/mrroffexplain.png" alt=""></p><p>当<code>mrr=on</code>时</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/mrrontime.png" alt=""></p><p>可以看到当mrr开启时, extra 的输出中多了 “Using MRR” 信息，即使用了 MRR Optimization IO 层面进行了优化，减少 IO 方面的开销</p><p>在时间上理论上可以查一个数量级,但是要在缓存池中没有预热以及查询的数据不在缓冲池中才可以</p><p>我测试的时候时间都差不多 (⊙﹏⊙)b</p><h2 id="7-2-ICP"><a href="#7-2-ICP" class="headerlink" title="7.2 ICP"></a>7.2 ICP</h2><p>ICP——Index Condition Pushdown</p><h3 id="7-2-1作用"><a href="#7-2-1作用" class="headerlink" title="7.2.1作用"></a>7.2.1作用</h3><p>在mysql数据库取出索引的同时,判断是否可以进行WHERE条件的过滤,也就是讲WHERE条件的过滤放到了存储引擎层,大大减少了上层SQL层对记录的fetch索取,以提高性能</p><h3 id="7-2-2-原理"><a href="#7-2-2-原理" class="headerlink" title="7.2.2 原理"></a>7.2.2 原理</h3><p>5.6 之前，在 SQL 语句的执行过程中，server 层通过 engine 的 api 获取数据，然后再进行 where_cond 的判断（具体判断逻辑在: evaluate_join_record），每一条数据都需要从engine层返回server层做判断。我们回顾一下上面把 ICP 关掉的测试，可以看到 Handler_read_next 的值陡增，其原因是第 1 个字段区分度不高，且 memo 字段无法使用索引，造成了类似 index 扫描的的情况，性能较低。</p><p>5.6 之后，在利用索引扫描的过程中，如果发现 where_cond 中含有这个 index 相关的条件，则将此条件记录在 handler 接口中，在索引扫描的过程中，只有满足索引与handler接口的条件时，才会返回到 server 层做进一步的处理，在前缀索引区分度不够，其它字段区分度高的情况下可以有效的减少 server &amp; engine之间的开销，提升查询性能。</p><p>开启ICP前查询方式如图所示:</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/index-access-2phases.png" alt=""></p><p>开启ICP后查询方式如图所示:</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/index-access-with-icp.png" alt=""></p><h3 id="7-2-3-开关ICP"><a href="#7-2-3-开关ICP" class="headerlink" title="7.2.3 开关ICP"></a>7.2.3 开关ICP</h3><pre><code class="mysql">默认是开启的查看MRR是否开启mysql&gt; select @@optimizer_switch\G*************************** 1. row ***************************@@optimizer_switch: index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on1 row in set (0.00 sec)注意上面的index_condition_pushdown=onSET optimizer_switch=&#39;index_condition_pushdown=on&#39;SET optimizer_switch=&#39;index_condition_pushdown=off&#39;</code></pre><h3 id="7-2-4-开关对比"><a href="#7-2-4-开关对比" class="headerlink" title="7.2.4 开关对比"></a>7.2.4 开关对比</h3><p>开启ICP时,使用explain语句时extra字段有<code>Using index condition</code>关键字</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/mrroffexplain.png" alt=""></p><h3 id="7-2-5-使用场景"><a href="#7-2-5-使用场景" class="headerlink" title="7.2.5 使用场景"></a>7.2.5 使用场景</h3><ul><li><p>只支持 select 语句；</p></li><li><p>MyISAM 与 InnoDB 引擎都起作用;</p></li><li><p>ICP的优化策略可用于range、ref、eq_ref、ref_or_null 类型的访问数据方法；</p></li><li><p>不支持主建索引，只支持辅助索引；</p></li><li><p>涉及子查询的不能起作用</p></li><li><p>作用于多列索引的情况最为明显</p><pre><code class="mysql">SELECT * FROM people  WHERE zipcode=&#39;95054&#39;  AND lastname LIKE &#39;%etrunia%&#39;  AND address LIKE &#39;%Main Street%&#39;;</code></pre></li></ul><h2 id="7-3-BKA"><a href="#7-3-BKA" class="headerlink" title="7.3 BKA"></a>7.3 BKA</h2><p>BKA——Batched Key Access</p><p>BKA的前辈是BNL:</p><h3 id="7-3-1-Block-Nested-Loop-Join算法"><a href="#7-3-1-Block-Nested-Loop-Join算法" class="headerlink" title="7.3.1 Block Nested-Loop Join算法"></a>7.3.1 Block Nested-Loop Join算法</h3><p>将外层循环的行/结果集存入join buffer, 内层循环的每一行与整个buffer中的记录做比较，从而减少内层循环的次数。主要用于当被join的表上无索引。</p><h3 id="7-3-2-Batched-Key-Access算法"><a href="#7-3-2-Batched-Key-Access算法" class="headerlink" title="7.3.2 Batched Key Access算法"></a>7.3.2 Batched Key Access算法</h3><p>当被join的表能够使用索引时，就先好顺序，然后再去检索被join的表。对这些行按照索引字段进行排序，因此减少了随机IO。如果被Join的表上没有索引，则使用老版本的BNL策略(BLOCK Nested-loop)。</p><h3 id="7-3-3-BKA和BNL标识"><a href="#7-3-3-BKA和BNL标识" class="headerlink" title="7.3.3 BKA和BNL标识"></a>7.3.3 BKA和BNL标识</h3><p>Explain下的Extra显示不同：</p><ul><li><p>Using join buffer (Batched Key Access)</p></li><li><p>Using join buffer (Block Nested Loop)</p></li></ul><pre><code class="mysql">相关参数BAK使用了MRR，要想使用BAK必须打开MRR功能，而MRR基于mrr_cost_based的成本估算并不能保证总是使用MRR，官方推荐设置mrr_cost_based=off来总是开启MRR功能。打开BAK功能(BAK默认OFF)：SET optimizer_switch=&#39;mrr=on,mrr_cost_based=off,batched_key_access=on&#39;;BKA使用join buffer size来确定buffer的大小，buffer越大，访问被join的表/内部表就越顺序。BNL默认是开启的，设置BNL相关参数：SET optimizer_switch=’block_nested_loop’支持inner join, outer join, semi-join operations,including nested outer joins</code></pre><p><code>BKA主要适用于join的表上有索引可利用，无索引只能使用BNL</code></p><h3 id="7-3-4-BKA-BNL-MRR的关系"><a href="#7-3-4-BKA-BNL-MRR的关系" class="headerlink" title="7.3.4 BKA BNL MRR的关系"></a>7.3.4 BKA BNL MRR的关系</h3><p>BKA = BNL + MRR</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/bka.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.Mysql索引介绍</title>
      <link href="/2020/02/16/6-Mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/02/16/6-Mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>【注意】主要介绍Innodb的索引结构</p><h2 id="6-1-Innodb索引组织表"><a href="#6-1-Innodb索引组织表" class="headerlink" title="6.1 Innodb索引组织表"></a>6.1 Innodb索引组织表</h2><p>和MyISAM的一个大区别,在Innodb的存储引擎中,表都是根据<code>主键</code>顺序组织存放的.我们把这种存储方式的表成为<code>索引组织表(index origanized table)</code>即大家常说的<code>IOT</code>方式</p><p>Innodb规定每一个表必须需要有主键(PK),主键的选择方式按照如下顺序选择:</p><ol><li>如有有定义主键 则选择此主键</li><li>如果为定义主键 选择<code>第一个定义的非空唯一索引</code>做主键:这里注意有三个条件:<code>非空</code>,<code>唯一</code>,<code>第一个满足以上两个条件的索引</code></li><li>如果以上两个都没有,Innodb会自动创建一个6字节大小的指针:隐式的创建,平时查询不能看到</li></ol><pre><code class="mysql">我们可以通过以下语句查看每一行的主键id,select *,_rowid form table;_rowid表示表的主键 需要注意的是 _rowid只能用于查看单个列为主键的情况 对于多列组成的主键就不好使了</code></pre><h2 id="6-1-Innodb逻辑存储结构"><a href="#6-1-Innodb逻辑存储结构" class="headerlink" title="6.1 Innodb逻辑存储结构"></a>6.1 Innodb逻辑存储结构</h2><p>之间介绍过Innodb库表的文件结构为两个:</p><pre><code>${tablename}.frm   #表结构文件${tablename}.idb   #表索引及数据文件</code></pre><p>所有的数据都被逻辑的存放在一个空间中(.idb文件中),我们称这个空间为<code>表空间(tablespace)</code></p><p>表空间的组成结构如下图所示:</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/innodb_engine_struct.png" alt=""></p><p>这样看可能不明显 再看一个:</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/tablespace.png" alt=""></p><pre><code>可以看到:表空间  ↓段segment  ↓区extent  ↓页page/块block   &lt;---最小储存单元而页里面包含了一个一个的行数据</code></pre><h3 id="6-2-1-表空间"><a href="#6-2-1-表空间" class="headerlink" title="6.2.1 表空间"></a>6.2.1 表空间</h3><p>在5.6以前所有的数据都存在共享表空间ibdata1中，在5.6以后加入了<code>innodb_file_per_table</code>参数默认是开启的,建议也是开启的,开启了这个参数后,每张表内的数据会单独放到一个表空间内</p><p>需要注意的是:每张表空间内存放的只有:</p><ul><li>数据</li><li>索引</li><li>插入缓存Bitmap</li></ul><p>其他的一些信息如:undo操作,插入缓存索引页,失误信息,double write buffer还是存在ibdata里</p><p>ibdata的具体介绍会在innodb索引章节进行介绍说明</p><h3 id="6-2-2-段"><a href="#6-2-2-段" class="headerlink" title="6.2.2 段"></a>6.2.2 段</h3><p>常见的段分类如下:</p><ul><li>数据段</li><li>索引段</li><li>回滚段</li></ul><h3 id="6-2-3-区"><a href="#6-2-3-区" class="headerlink" title="6.2.3 区"></a>6.2.3 区</h3><p>区是由<code>连续的页</code>组成的空间,<code>在任何情况下每个区的大小都为1MB</code></p><p>为了保证区的连续性,每次存储引擎都会从磁盘申请四五个区</p><p>默认情况下,Innodb页的大小为16KB,即一个区共有64个页  =&gt; (2^10) / (2^4)</p><p>页的大小可以在初始化的时候进行调整,但是区的大小总为1MB</p><h3 id="6-2-4-页"><a href="#6-2-4-页" class="headerlink" title="6.2.4 页"></a>6.2.4 页</h3><p>页是InnoDB存储引擎磁盘管理的最小单位，每个页默认16KB</p><p>可以通过参数<code>innodb_page_size</code>将页的大小设置为4K、8K、16K</p><p>若设置完成，则所有表中页的大小都为innodb_page_size，不可以再次对其进行修改</p><p>除非通过mysqldump导入和导出操作来产生新的库</p><p>innodb的所有数据文件（后缀为ibd的文件），他的大小始终都是<code>innodb_page_size</code> (16384(16k))的整数倍</p><pre><code>[root@centos7-1 baseinfo]# ll|grep &#39;ibd&#39; -rw-r-----. 1 mysql mysql 2663383040 xxx.ibd  =&gt; 2663383040 = 16384*162560-rw-r-----. 1 mysql mysql  868220928 ccc.ibd  =&gt; 868220928 = 16384*52992</code></pre><p><code>innodb_page_size</code>的大小限制了tablespace表空间的大小:</p><p>Table 14.25 InnoDB Maximum Tablespace Size</p><table><thead><tr><th>InnoDB Page Size</th><th>Maximum Tablespace Size</th></tr></thead><tbody><tr><td>4KB</td><td>16TB</td></tr><tr><td>8KB</td><td>32TB</td></tr><tr><td>16KB</td><td>64TB</td></tr><tr><td>32KB</td><td>128TB</td></tr><tr><td>64KB</td><td>256TB</td></tr></tbody></table><h3 id="6-2-5-行"><a href="#6-2-5-行" class="headerlink" title="6.2.5 行"></a>6.2.5 行</h3><p>Innodb存储引擎是面向列的,也就是数据是按行存放的,每个页存放行的记录也是有硬性规定的</p><p>最多允许存放16KB/2-200行记录,即7992行</p><p>但实际上互联网公司一行的数据大概为1KB,即一个page可以存放16行数据</p><h2 id="6-3-B-树结构"><a href="#6-3-B-树结构" class="headerlink" title="6.3 B+树结构"></a>6.3 B+树结构</h2><p>无论是MyISAM还是Innodb 他们在存储数据时,都用到了B+树结构</p><h3 id="6-3-1-B-树结构"><a href="#6-3-1-B-树结构" class="headerlink" title="6.3.1 B+树结构"></a>6.3.1 B+树结构</h3><p>(1) 原理图:</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/BTree.png" alt=""></p><p>(2)特点：</p><ul><li>非叶子节点只存储键值信息</li><li>所有叶子节点之间都有一个链指针</li><li>叶子节点也多存储了指向下一个叶子节点的指针，更方便叶子节点的范围遍历</li><li>数据记录都存放在叶子节点中</li><li>所有的叶子节点组成一个循环双向链表</li></ul><h3 id="6-3-2-MyISAM实现B-Tree"><a href="#6-3-2-MyISAM实现B-Tree" class="headerlink" title="6.3.2 MyISAM实现B+Tree"></a>6.3.2 MyISAM实现B+Tree</h3><p>(1)原理图：</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/MtISAMBTree.png" alt=""></p><p>(2)特点：</p><ul><li>索引文件和数据文件是分离的</li><li>索引文件仅保存数据行记录的地址（行指针）</li><li>主索引与二级索引无区别</li><li>二级索引也存储的是行指针</li></ul><h3 id="6-3-3-Innodb实现B-Tree"><a href="#6-3-3-Innodb实现B-Tree" class="headerlink" title="6.3.3 Innodb实现B+Tree"></a>6.3.3 Innodb实现B+Tree</h3><p>(1)原理图：</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/InnodbBtree.png" alt=""></p><p>(2)特点：</p><ul><li>主键索引既存储索引值，又在叶子节点中存储整行的数据</li><li>二级索引存储索引列值+主键信息</li><li>必须有主键 主键的选择如前文所释</li></ul><h2 id="6-4-索引分类"><a href="#6-4-索引分类" class="headerlink" title="6.4 索引分类"></a>6.4 索引分类</h2><p>我们根据索引文件是否和数据文件共同存储,可讲索引分为:</p><ul><li>聚簇索引(聚集索引)</li><li>非聚簇索引(辅助索引)</li></ul><p>不管是聚簇索引还是非聚簇索引我们看到他们内部都是B+树的,即高度平衡的,他们之间的区别是叶子节点是否存放的是一整行数据信息</p><h3 id="6-4-1-聚簇索引"><a href="#6-4-1-聚簇索引" class="headerlink" title="6.4.1 聚簇索引"></a>6.4.1 聚簇索引</h3><p>Innodb的数据页同B+树数据结构一样,每个页都通过一个双向链表来进行链接。</p><p>由于实际的数据页只能按照一颗B+树进行排序,因此每张表只能拥有一个<code>聚簇索引</code></p><p>在多数情况下,查询优化器倾向与采用聚簇索引:</p><ul><li>聚簇索引能够在叶子节点上直接找到数据</li><li>由于定义了数据的逻辑顺序,聚簇索引能够特别快的访问针对范围值的查询</li></ul><p>【注意】聚簇索引的存储并不是物理上连续的,而是逻辑上连续的:</p><ul><li>页通过双向链表链接,页按照主键的顺序排序</li><li>每个页的记录也是通过双向链表进行维护的,物理储存上可以同样不按照主键存储</li></ul><h3 id="6-4-1-非聚集索引"><a href="#6-4-1-非聚集索引" class="headerlink" title="6.4.1 非聚集索引"></a>6.4.1 非聚集索引</h3><p>对于非聚集索引,叶子节点不包含行记录的全部数据。叶子节点除了包含主键值以外,每个叶子节点的索引行还包含了一个书签(bookmark),在Innodb数据引擎中,这个bookmark就代表相应行数据的聚集索引键</p><p>他们之间的关系如下:</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/IndexRelat.jpg" alt=""></p><p>辅助索引的存在并不影响数据在聚集索引中的组织，因此<code>每张表上可以有多个辅助索引，但只能有一个聚集索引</code>。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶子级别的指针获得只想主键索引的主键，然后再通过主键索引来找到一个完整的行记录。</p><p>举例来说，如果在一棵高度为3的辅助索引树种查找数据，那需要对这个辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问才能得到最终的一个数据页。</p><p>当然后面优化器部分会有相应的优化算法来优化IO次数</p><h2 id="6-4-索引作用"><a href="#6-4-索引作用" class="headerlink" title="6.4 索引作用"></a>6.4 索引作用</h2><blockquote><p>索引是存储引擎用于快速找到记录的一种数据结构,这是索引的基本功能</p></blockquote><h3 id="6-4-1-索引的优点"><a href="#6-4-1-索引的优点" class="headerlink" title="6.4.1 索引的优点"></a>6.4.1 索引的优点</h3><ul><li>索引大大检索了服务器需要扫描的数据量</li><li>索引可以帮助服务器避免排序和临时表</li><li>索引可以将随机IO变为顺序IO</li></ul><h3 id="6-4-2-索引平衡"><a href="#6-4-2-索引平衡" class="headerlink" title="6.4.2 索引平衡"></a>6.4.2 索引平衡</h3><p>索引太多,应用程序的性能可能受到影响,索引太少,对查询性能又会产生影响,要找到一个平衡点至关重要。</p><p>不要总是在事后才想起添加索引,设计表时要知道数据的使用,从一开始就应该在需要处添加索引</p><p>当然索引并不一定是最好的解决方案:</p><ul><li><p>在创建索引，更新数据表的时候，会给数据库带来额外的消耗。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。</p></li><li><p>对于非常小的表，大部分情况下全表扫描更高效。</p></li><li><p>对于中到大型的表，索引特别有效</p></li><li><p>但是对于特大型的表，建立和使用索引带来的代价将随之增长，这种情况下，需要使用一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录的匹配。例如分区表技术;</p></li></ul><h2 id="6-5-索引种类"><a href="#6-5-索引种类" class="headerlink" title="6.5 索引种类"></a>6.5 索引种类</h2><ul><li>聚簇索引<ul><li>主键索引</li></ul></li><li>非聚簇索引<ul><li>普通单列索引</li><li>唯一索引</li><li>前缀索引</li><li>多列索引</li></ul></li></ul><h3 id="6-5-1-主键索引"><a href="#6-5-1-主键索引" class="headerlink" title="6.5.1 主键索引"></a>6.5.1 主键索引</h3><p>必须要有的索引，用于构建聚簇索引的基本条件</p><p>一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。</p><p>关键字及创建方式:</p><pre><code class="mysql">  PRIMARY KEY (`id`)</code></pre><h3 id="6-5-2-普通单列索引"><a href="#6-5-2-普通单列索引" class="headerlink" title="6.5.2 普通单列索引"></a>6.5.2 普通单列索引</h3><p>普通索引是最基本的索引类型，唯一的任务是加快对数据的访问速度，没有任何限制。</p><p>关键字及创建方式:</p><pre><code class="mysql">CREATE INDEX index_name ON TABLE(column_name);ALTER TABLE table_name ADD INDEX index_name(column_name);INDEX index_name (name(length))</code></pre><h3 id="6-5-3-唯一索引"><a href="#6-5-3-唯一索引" class="headerlink" title="6.5.3 唯一索引"></a>6.5.3 唯一索引</h3><p>索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p><p>关键字及创建方式:</p><pre><code class="mysql">UNIQUE INDEX index_name (column_name)CREATE UNIQUE INDEX index_name ON mytable(column_name)ALTER TABLE table_name ADD UNIQUE indexName(column_name)</code></pre><h3 id="6-5-4-前缀索引"><a href="#6-5-4-前缀索引" class="headerlink" title="6.5.4 前缀索引"></a>6.5.4 前缀索引</h3><p>有时候需要索引很长的字符列，这会让索引变得大且慢。</p><p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指不重复的索引值（也称为基数，cardinality)和数据表的记录总数的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><p>一般情况下某个前缀的选择性也是足够高的，足以满足查询性能。对于BLOB，TEXT，或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p><p>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引的整个列。</p><p>换句话说，<code>前缀的”基数“应该接近于完整的列的”基数“</code>。</p><p>【注意】前缀索引只能作用在普通索引上 不能作用在唯一索引上</p><p>那就是计算完整列的选择性，并使其前缀的选择性接近于完整列的选择性。下面显示如何计算完整列的选择性：</p><pre><code class="mysql">mysql&gt; select count(distinct city) / count(*) from city_demo;+---------------------------------+| count(distinct city) / count(*) |+---------------------------------+|                          0.4283 |+---------------------------------+1 row in set (0.05 sec)</code></pre><p>可以在一个查询中针对不同前缀长度的选择性进行计算，这对于大表非常有用，下面给出如何在同一个查询中计算不同前缀长度的选择性：</p><pre><code class="mysql">mysql&gt; select count(distinct left(city,3))/count(*) as sel3,    -&gt; count(distinct left(city,4))/count(*) as sel4,    -&gt; count(distinct left(city,5))/count(*) as sel5,     -&gt; count(distinct left(city,6))/count(*) as sel6     -&gt; from city_demo;+--------+--------+--------+--------+| sel3   | sel4   | sel5   | sel6   |+--------+--------+--------+--------+| 0.3367 | 0.4075 | 0.4208 | 0.4267 |+--------+--------+--------+--------+1 row in set (0.01 sec)</code></pre><p>可以看见当索引前缀为6时的基数是0.4267，已经接近完整列选择性0.4283。</p><p>在上面的示例中，已经找到了合适的前缀长度，下面创建前缀索引：</p><pre><code class="mysql">mysql&gt; alter table city_demo add key (city(6));Query OK, 0 rows affected (0.19 sec)Records: 0  Duplicates: 0  Warnings: 0</code></pre><p>前缀索引是一种能使索引更小，更快的有效办法，但另一方面也有其<code>缺点</code>：</p><ul><li>mysql无法使用其前缀索引做ORDER BY和GROUP BY</li><li>无法使用前缀索引做覆盖扫描。</li></ul><h3 id="6-5-5-多列索引"><a href="#6-5-5-多列索引" class="headerlink" title="6.5.5 多列索引"></a>6.5.5 多列索引</h3><p>指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。</p><p>关键字及创建方式:</p><pre><code class="mysql">ALTER TABLE table ADD INDEX name_city_age (name,city,age);</code></pre><p>联合索引在内部的结构图如下图所示:</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/unionindex.png" alt=""></p><p>对于联合索引（a,b），where a =xxx and b =xxx，和where a=xxx 可以使用此联合索引，但是对于where b = xxx不能使用，因为b列数据在此联合索引上不是有序的。具体的索引是否生效会在以后章节介绍。</p><h2 id="6-6-覆盖索引"><a href="#6-6-覆盖索引" class="headerlink" title="6.6 覆盖索引"></a>6.6 覆盖索引</h2><h3 id="6-6-1-定义"><a href="#6-6-1-定义" class="headerlink" title="6.6.1 定义"></a>6.6.1 定义</h3><p>SQL只需要通过索引就可以返回查询所需要的数据，而不必通过二级索引查到主键之后再去查询数据。</p><p>这样可以减少大量的IO操作,无需进行回表操作。</p><h3 id="6-6-2-判断标准"><a href="#6-6-2-判断标准" class="headerlink" title="6.6.2 判断标准"></a>6.6.2 判断标准</h3><p>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为<code>using index</code>,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</p><h3 id="6-6-3-优点"><a href="#6-6-3-优点" class="headerlink" title="6.6.3 优点"></a>6.6.3 优点</h3><p>覆盖索引是一种非常强大的工具，能大大提高查询性能，只需要读取索引而不用读取数据有以下一些优点<br>1、索引项通常比记录要小，所以MySQL访问更少的数据<br>2、索引都按值的大小顺序存储，相对于随机访问记录，需要更少的I/O<br>3、大多数据引擎能更好的缓存索引，比如MyISAM只缓存索引<br>4、覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了</p><h2 id="6-7-索引管理"><a href="#6-7-索引管理" class="headerlink" title="6.7 索引管理"></a>6.7 索引管理</h2><p>我们可以通过<code>SHOW INDEX FROM table</code>查看表的索引情况</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/showindex.png" alt=""></p><p>具体每个字段的含义如下:</p><p>下面我们一起了解下返回的这张表的含义：</p><ol><li>Table: 表名</li><li>Non_unique: 如果索引不能包括重复值则为0，如果可以则为1。也就是平时所说的唯一索引。</li><li>Key_name 索引名称，如果名字相同则表明是同一个索引，而并不是重复，比如上图中的而三条数据，其实是一个联合索引。</li><li>Seq_in_index 索引中的列序列号，从1开始。上图中的二、三数据，Seq_in_index一个是1一个是2，就是表明在联合索引中的顺序，我们就能推断出联合索引中索引的前后顺序。</li><li>Column_name 索引的列名。</li><li>Collation指的是列以什么方式存储在索引中，可是A或NULL,Btree总是A,即排序的。</li><li>Cardinality 是基数的意思，表示索引中唯一值的数目的估计值。我们知道某个字段的重复值越少越适合建索引，所以我们一般都是根据Cardinality来判断索引是否具有高选择性，如果这个值非常小，那就需要重新评估这个字段是否适合建立索引。</li><li>Sub_part 前置索引的意思，如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。</li><li>Packed 指示关键字如何被压缩。如果没有被压缩，则为NULL。压缩一般包括压缩传输协议、压缩列解决方案和压缩表解决方案。</li><li>.Null 如果列含有NULL，则含有YES。</li><li>.Index_type表示索引类型，Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。</li><li>.Comment Index_comment 注释的意思。</li></ol><h3 id="6-7-1-什么是Cardinality"><a href="#6-7-1-什么是Cardinality" class="headerlink" title="6.7.1 什么是Cardinality"></a>6.7.1 什么是Cardinality</h3><p>不是所有的查询条件出现的列都需要添加索引。对于什么时候添加B+树索引。一般的经验是，在访问表中很少一部分时使用B+树索引才有意义。对于性别字段、地区字段、类型字段，他们可取值范围很小，称为低选择性。如</p><pre><code class="mysql">SELECT * FROM student WHERE sex=&#39;M&#39;</code></pre><p>按性别进行查询时，可取值一般只有M、F。</p><p>因此SQL语句得到的结果可能是该表50%的数据(加入男女比例1:1)这时添加B+树索引是完全没有必要的。</p><p>相反，如果某个字段的取值范围很广，几乎没有重复，属于高选择性。则此时使用B+树的索引是最合适的。</p><p>例如对于姓名字段，基本上在一个应用中不允许重名的出现</p><h3 id="6-7-2-查看高选择性"><a href="#6-7-2-查看高选择性" class="headerlink" title="6.7.2 查看高选择性"></a>6.7.2 查看高选择性</h3><p>怎样查看索引是否有高选择性？通过SHOW INDEX结果中的列Cardinality来观察。非常关键，表示所以中不重复记录的预估值，需要注意的是Cardinality是一个预估值，而不是一个准确值基本上用户也不可能得到一个准确的值</p><p>在实际应用中，<code>Cardinality/n_row_in_table应尽可能的接近1</code>，如果非常小,那用户需要考虑是否还有必要创建这个索引。故在访问高选择性属性的字段并从表中取出很少一部分数据时，对于字段添加B+树索引是非常有必要的。如</p><pre><code class="mysql">SELECT * FROM member WHERE usernick=&#39;David&#39;;</code></pre><p>表member大约有500W行数据,usernick字段上有一个唯一索引。这也符号提到的高选择性</p><h3 id="6-7-3-Cardinality统计"><a href="#6-7-3-Cardinality统计" class="headerlink" title="6.7.3 Cardinality统计"></a>6.7.3 Cardinality统计</h3><p>Cardinality统计时放在存储引擎层进行的</p><p>在生成环境中，索引的更新操作可能非常频繁。如果每次索引在发生操作时就对其进行Cardinality统计，那么将会对数据库带来很大的负担。另外需要考虑的是，如果一张表的数据非常大，如一张表有50G的数据，那么统计一次Cardinality信息所需要的时间可能非常长。这样的环境下，是不能接受的。因此，数据库对于Cardinality信息的统计都是通过采样的方法完成</p><p>在InnoDB存储引擎中，Cardinality统计信息的更新发生在两个操作中：insert和update。InnoDB存储引擎内部对更新Cardinality信息的策略为:</p><ul><li>表中1/16的数据已发生了改变</li><li>stat_modified_counter&gt;2000 000 000</li></ul><p>接着考虑InnoDB存储引擎内部是怎样进行Cardinality信息统计和更新操作呢？同样是通过采样的方法。默认的InnoDB存储引擎对8个叶子节点Leaf Page进行采用。采用过程如下</p><ol><li>取得B+树索引中叶子节点的数量，记为A</li><li>随机取得B+树索引中的8个叶子节点，统计每个页不同记录的个数，即为P1，P2….P8</li><li>通过采样信息给出Cardinality的预估值:Cardinality=(P1+P2+…+P8)*A/8</li></ol><p>根据上述的说明可以发现，在InnoDB存储引擎中，Cardinality值通过对8个叶子节点预估而得的。而<code>不是一个实际精确的值</code>。再者，每次对Cardinality值的统计，都是通过随机取8个叶子节点得到的，这同时有暗示了另外一个Cardinality现象，即每次得到的Cardinality值可能不同的;</p><p>当然，有一种情况可以使得用户每次观察到的索引Cardinality值是一样的。那就是表足够小，表的叶子节点树小于或者等于8个</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.MySQL体系结构</title>
      <link href="/2020/02/15/4-Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2020/02/15/4-Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-Mysql整体结构图"><a href="#4-1-Mysql整体结构图" class="headerlink" title="4. 1 Mysql整体结构图"></a>4. 1 Mysql整体结构图</h2><p>下图是Mysql官方给出的结构图:</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="Mysql体系结构"></p><p>从上图可以发现Mysql由以下几部分组成</p><ul><li>客户端</li><li>连接层</li><li>SQL层</li><li>存储引擎层</li><li>文件系统</li><li>服务管理(非必须)</li></ul><h3 id="4-1-1-客户端"><a href="#4-1-1-客户端" class="headerlink" title="4.1.1 客户端"></a>4.1.1 客户端</h3><p>即Mysql提供给不同语言的API链接方式,支持的语言有很过Go,PHP,Java等等 没啥好说的哈</p><h3 id="4-1-2-连接层"><a href="#4-1-2-连接层" class="headerlink" title="4.1.2 连接层"></a>4.1.2 连接层</h3><p>主要负责以下功能:</p><ul><li>提供链接协议,两种: <code>socket连接&amp;TCP/IP连接</code></li><li>授权认证</li><li>提供专用的连接线程</li><li>最大连接数限制</li></ul><h3 id="4-1-3-SQL层"><a href="#4-1-3-SQL层" class="headerlink" title="4.1.3  SQL层"></a>4.1.3  SQL层</h3><p>主要负责以下功能:</p><ul><li>SQL语法检查</li><li>语义检查(DML,DCL,DQL,DTL)</li><li>权限判断</li><li>解析器:解析预处理,执行计划(是全表扫描还是走哪个索引)</li><li>优化分析器:帮我们选择最优的方案</li><li>执行器:执行SQL语句</li><li>查询缓存(QC)<ul><li>【注】这个不要开启,在许多情况下它会失效并且会拉低数据库性能</li><li>可以使用Redis来替代</li></ul></li></ul><h3 id="4-1-4-存储引擎层"><a href="#4-1-4-存储引擎层" class="headerlink" title="4.1.4 存储引擎层"></a>4.1.4 存储引擎层</h3><p>提供不同的存储引擎以供选择,类似于Linux的文件系统,和磁盘模块进行数据交互</p><p>我们可以通过show engine指令查看目前数据库支持的存储引擎</p><pre><code>[root@centos7-1 3306]# mysql -e&#39;show engines&#39;|awk &#39;{print $1}&#39;EngineCSVMRG_MYISAMMyISAM        ***BLACKHOLEPERFORMANCE_SCHEMAMEMORY          ARCHIVEInnoDB          *****FEDERATED</code></pre><p>经常提到的存储引擎有两个:</p><ul><li>InnoDB</li><li>MyISAM</li></ul><p>在早期使用的默认存储引擎为MyISAM,目前默认都是用InnoDB,他们之间的区别稍后会在存储引擎一篇中详细介绍</p><h3 id="4-1-5-文件系统"><a href="#4-1-5-文件系统" class="headerlink" title="4.1.5 文件系统"></a>4.1.5 文件系统</h3><p>用于存储数据文件和不同类型的日志</p><h2 id="4-2-MySQL文件结构"><a href="#4-2-MySQL文件结构" class="headerlink" title="4.2 MySQL文件结构"></a>4.2 MySQL文件结构</h2><p>目前我们的Mysql数据库下有以下几个库:</p><pre><code>mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || baseinfo           || mysql              || performance_schema || sys                || test               |+--------------------+6 rows in set (0.00 sec)</code></pre><p>我们查看MySQL的数据存储文件夹下会看到如下文件:</p><pre><code>[root@centos7-1 3306]# tree -L 1.├── auto.cnf├── baseinfo├── centos7-1.err├── centos7-1.pid├── ib_buffer_pool├── ibdata1├── ib_logfile0├── ib_logfile1├── ibtmp1├── mysql├── performance_schema├── sys└── test</code></pre><p>意义如下:</p><pre><code>[root@centos7-1 3306]# tree -L 1.├── auto.cnf               #Mysql自动生成的一些配置文件├── baseinfo            #baseinfo库里的文件【自建库】├── centos7-1.err       #数据库错误日志 命名方式为 主机名+“.err”├── centos7-1.pid       #数据里的进程id文件├── ib_buffer_pool      #一些持久化了的buffer pool文件├── ibdata1             #ibddata文件存储临时表数据+用户数据├── ib_logfile0         #ib_logfile0～N为 redo log日志├── ib_logfile1├── ibtmp1              #临时表空间文件├── mysql               #Mysql库文件├── performance_schema  #performance_schema库文件夹【系统库】├── sys                    #sys库文件夹【系统库】└── test                #自建test库文件夹【自建库】</code></pre><p>我们看到baseinfo库为Innodb存储引擎库,而test为MyISAM存储引擎库, 他们在文件存储上又有不同之处:</p><pre><code>[root@centos7-1 3306]# tree testtest├── db.opt├── t1.frm├── t1.MYD└── t1.MYI0 directories, 4 files[root@centos7-1 3306]# tree baseinfo/baseinfo/├── db.opt├── t_scrm_map.frm├── t_scrm_map.ibd├── t_scrm_pet_info.frm├── t_scrm_pet_info.ibd├── t_scrm_user_info.frm└── t_scrm_user_info.ibd[root@centos7-1 test]# cat db.opt default-character-set=utf8mb4default-collation=utf8mb4_general_ci#db.opt的作用1、create database时会自动生成一个文件db.opt，存放的数据库的默认字符集，show create database时显示数据库默认字符集即db.opt中字符集2、这个文件丢失不影响数据库运行，该文件丢失之后新建表时，找不到数据库的默认字符集，就把character_set_server当成数据库的默认字符集，show create database时显示character_set_server字符集</code></pre><p>可以看到MyISAM库表的文件结构为三个:</p><pre><code>${tablename}.frm   #表结构文件${tablename}.MYI   #表索引文件 MyISAM Index${tablename}.MYD   #表数据文件 MyISAM Data</code></pre><p>而Innodb库表的文件结构为两个:</p><pre><code>${tablename}.frm   #表结构文件${tablename}.idb   #表索引及数据文件</code></pre><p>可以看到在文件存储上 MyISAM和Innodb就有截然不同的结构 从而造成了数据引擎上的巨大差异</p><h2 id="4-3-MySQL运行模式"><a href="#4-3-MySQL运行模式" class="headerlink" title="4.3  MySQL运行模式"></a>4.3  MySQL运行模式</h2><p>MySQL被设计成一个单进程多线程架构的数据库,这一点与SQL Server比较类似,但与Oracle多进程的架构不同</p><p><code>MySQL数据库实例在系统上表现就是一个进程</code></p><p>已Innodb存储引擎为例,包含的后台线程主要有四种（具体含义会在存储引擎章节做解释）:</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/Mysqld%E8%BF%9B%E7%A8%8B.png" alt=""></p><p>我们可以在mysql中执行以下语句看查看所有mysql的进程数,具体含义在innodb章节解释吧:</p><pre><code class="mysql">mysql&gt; select thread_id,name,type FROM performance_schema.threads;+-----------+----------------------------------------+------------+| thread_id | name                                   | type       |+-----------+----------------------------------------+------------+|         1 | thread/sql/main                        | BACKGROUND ||         2 | thread/sql/thread_timer_notifier       | BACKGROUND ||         3 | thread/innodb/io_ibuf_thread           | BACKGROUND ||         4 | thread/innodb/io_log_thread            | BACKGROUND ||         5 | thread/innodb/io_read_thread           | BACKGROUND ||         6 | thread/innodb/io_read_thread           | BACKGROUND ||         7 | thread/innodb/io_read_thread           | BACKGROUND ||         8 | thread/innodb/io_read_thread           | BACKGROUND ||         9 | thread/innodb/io_write_thread          | BACKGROUND ||        10 | thread/innodb/io_write_thread          | BACKGROUND ||        11 | thread/innodb/io_write_thread          | BACKGROUND ||        12 | thread/innodb/io_write_thread          | BACKGROUND ||        13 | thread/innodb/page_cleaner_thread      | BACKGROUND ||        16 | thread/innodb/srv_lock_timeout_thread  | BACKGROUND ||        17 | thread/innodb/srv_error_monitor_thread | BACKGROUND ||        18 | thread/innodb/srv_monitor_thread       | BACKGROUND ||        19 | thread/innodb/srv_master_thread        | BACKGROUND ||        20 | thread/innodb/srv_worker_thread        | BACKGROUND ||        21 | thread/innodb/srv_purge_thread         | BACKGROUND ||        22 | thread/innodb/srv_worker_thread        | BACKGROUND ||        23 | thread/innodb/srv_worker_thread        | BACKGROUND ||        24 | thread/innodb/buf_dump_thread          | BACKGROUND ||        25 | thread/innodb/dict_stats_thread        | BACKGROUND ||        26 | thread/sql/signal_handler              | BACKGROUND ||        27 | thread/sql/compress_gtid_table         | FOREGROUND ||        36 | thread/sql/one_connection              | FOREGROUND |+-----------+----------------------------------------+------------+26 rows in set (0.00 sec)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.MysqlSQL基础</title>
      <link href="/2020/02/15/5-MysqlSQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/02/15/5-MysqlSQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-常用数据类型"><a href="#5-1-常用数据类型" class="headerlink" title="5.1 常用数据类型"></a>5.1 常用数据类型</h2><h3 id="5-1-1-整型"><a href="#5-1-1-整型" class="headerlink" title="5.1.1 整型"></a>5.1.1 整型</h3><table><thead><tr><th align="center">类型</th><th align="center">字节</th><th align="center">范围(有符号位)</th></tr></thead><tbody><tr><td align="center">TINYINT</td><td align="center">1Byte</td><td align="center">0~2^8 OR  -2^7 ~ 2^7-1</td></tr><tr><td align="center">INT</td><td align="center">4Byte</td><td align="center">0~2^32 OR  -2^31 ~ 2^31-1</td></tr><tr><td align="center">BIGINT</td><td align="center">8Byte</td><td align="center">0~2^64 OR -2^63 ~ 2^63-1</td></tr></tbody></table><ul><li>int(M)  M表示总位数<ul><li>如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改</li><li>例：int(5)   插入一个数’123’，补填后为’00123’</li></ul></li><li>默认存在符号位，unsigned 属性修改</li><li>在满足要求的情况下，越小越好</li><li>1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型</li></ul><h3 id="5-1-2-小数"><a href="#5-1-2-小数" class="headerlink" title="5.1.2 小数"></a>5.1.2 小数</h3><table><thead><tr><th align="center">类型</th><th align="center">字节</th><th align="center">范围(有符号位)</th></tr></thead><tbody><tr><td align="center">float(单精度)</td><td align="center">4Byte</td><td align="center">自定义，表示近似值</td></tr><tr><td align="center">double(双精度)</td><td align="center">8Byte</td><td align="center">自定义，表示近似值</td></tr><tr><td align="center">decimal</td><td align="center">自定义</td><td align="center">自定义,表示精确数值</td></tr></tbody></table><ul><li><p>浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性，不同于整型，前后均会补填0</p></li><li><p>支持科学计数法表示。</p></li><li><p>定义浮点型时，需指定总位数和小数位数。</p><blockquote><p>float(M, D)     double(M, D)</p><p>M表示总位数，D表示小数位数</p><p>M和D的大小会决定浮点数的范围 不同于整型的固定范围</p><p>M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）</p><p>decimal(M, D)   M也表示总位数，D表示小数位数</p><p>保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入<br>将浮点数转换为字符串来保存，每9位数字保存为4个字节</p></blockquote></li></ul><h3 id="5-1-3-字符"><a href="#5-1-3-字符" class="headerlink" title="5.1.3 字符"></a>5.1.3 字符</h3><table><thead><tr><th align="center">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">CHAR</td><td align="left">定长字符串最多255个字符</td></tr><tr><td align="center">VARCHAR</td><td align="left">变长字符串最多65535个字符</td></tr><tr><td align="center">TEXT</td><td align="left">变长字符串最多65535个字符类型，在定义时,不需要定义长度<br/>也不会计算总长度不可给default值</td></tr><tr><td align="center">BLOB</td><td align="left">二进制字符串（字节字符串）</td></tr><tr><td align="center">ENUM</td><td align="left">枚举类型 smallint 存储</td></tr><tr><td align="center">SET</td><td align="left">集合类型 bigint存储</td></tr></tbody></table><pre><code>char(11) ：定长字符串类型,在存储字符串时，最大字符长度11个，立即分配11个字符长度的存储空间，如果存不满，空格填充varchar(11):变长的字符串类型看，最大字符长度11个。在存储字符串时，自动判断字符长度，按需分配存储空间。M表示能存储的最大长度，此长度是字符数，非字节数。不同的编码，所占用的空间不同。char,最多255个字符，与编码无关。varchar,最多65535字符，与编码有关。一条有效记录最大不能超过65535个字节。utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符【注】varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。varchar 的最大有效长度由最大行大小和使用的字符集确定。最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？答：(65535-1-2-4-30*3)/3</code></pre><pre><code>枚举类型说明enum(val1, val2, val3...)在已知的值中进行单选。最大数量为65535.枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。表现为字符串类型，存储却是整型。NULL值的索引是NULL。空字符串错误值的索引值是0枚举类型，比较适合于将来此列的值是固定范围内的特点，可以使用enum,可以很大程度的优化我们的索引结构</code></pre><pre><code class="mysql">集合类型说明set(val1, val2, val3...)create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );insert into tab values (&#39;男, 女&#39;);最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式当创建表时，SET成员值的尾部空格将自动被删除</code></pre><h3 id="5-1-4-时间"><a href="#5-1-4-时间" class="headerlink" title="5.1.4 时间"></a>5.1.4 时间</h3><table><thead><tr><th align="center">类型</th><th align="center">字节</th><th align="center">说明</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">datetime</td><td align="center">8Byte</td><td align="center">日期及时间</td><td align="center">1000-01-01 00:00:00 到 9999-12-31 23:59:59</td></tr><tr><td align="center">date</td><td align="center">3Byte</td><td align="center">日期</td><td align="center">1000-01-01 到 9999-12-31</td></tr><tr><td align="center">timestamp</td><td align="center">4Byte</td><td align="center">时间戳</td><td align="center">19700101000000 到 2038-01-19 03:14:07</td></tr><tr><td align="center">time</td><td align="center">3Byte</td><td align="center">时间</td><td align="center">-838:59:59 到 838:59:59</td></tr><tr><td align="center">year</td><td align="center">1Byte</td><td align="center">年份</td><td align="center">1901 - 2155</td></tr></tbody></table><h2 id="5-2-列属性"><a href="#5-2-列属性" class="headerlink" title="5.2 列属性"></a>5.2 列属性</h2><h3 id="5-2-1-PRIMARY"><a href="#5-2-1-PRIMARY" class="headerlink" title="5.2.1 PRIMARY"></a>5.2.1 PRIMARY</h3><ul><li>能唯一标识记录的字段，可以作为主键。</li><li>一个表只能有一个主键。</li><li>主键具有唯一性。</li><li>声明字段时，用 primary key 标识。</li><li>也可以在字段列表之后声明：create table tab ( id int, stu varchar(10), primary key (id));</li><li>主键字段的值不能为null。</li><li>主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。<br>  例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));</li></ul><h3 id="5-2-2-UNIQUE"><a href="#5-2-2-UNIQUE" class="headerlink" title="5.2.2 UNIQUE"></a>5.2.2 UNIQUE</h3><p>唯一索引,使得某字段的值也不能重复。</p><h3 id="5-2-3-NULL"><a href="#5-2-3-NULL" class="headerlink" title="5.2.3 NULL"></a>5.2.3 NULL</h3><ul><li>null不是数据类型，是列的一个属性。</li><li>表示当前列是否可以为null，表示什么都没有。</li><li>null, 允许为空。默认；not null, 不允许为空。</li><li>insert into tab values (null, ‘val’); – 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</li></ul><h3 id="5-2-4-DEFAULT"><a href="#5-2-4-DEFAULT" class="headerlink" title="5.2.4 DEFAULT"></a>5.2.4 DEFAULT</h3><ul><li>当前字段的默认值。<pre><code class="mysql">#表示强制使用默认值insert into tab values (default, &#39;val&#39;);#表示将当前时间的时间戳 设为默认值create table tab ( add_time timestamp default current_timestamp )</code></pre></li></ul><h3 id="5-2-5-AUTO-INCREMENT"><a href="#5-2-5-AUTO-INCREMENT" class="headerlink" title="5.2.5 AUTO_INCREMENT"></a>5.2.5 AUTO_INCREMENT</h3><ul><li>自动增长约束</li><li>自动增长必须为索引（主键或unique）</li><li>只能存在一个字段为自动增长。</li><li>默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;</li></ul><h3 id="5-2-6-COMMENT"><a href="#5-2-6-COMMENT" class="headerlink" title="5.2.6 COMMENT"></a>5.2.6 COMMENT</h3><p>注释<br>例：create table tab ( id int ) comment ‘注释内容’;</p><h3 id="5-2-7-FOREIGN-KEY"><a href="#5-2-7-FOREIGN-KEY" class="headerlink" title="5.2.7 FOREIGN KEY"></a>5.2.7 FOREIGN KEY</h3><p>外键约束 高并发下不建议使用 ERP中常用</p><h2 id="5-3-表属性"><a href="#5-3-表属性" class="headerlink" title="5.3 表属性"></a>5.3 表属性</h2><h3 id="5-3-1-engine"><a href="#5-3-1-engine" class="headerlink" title="5.3.1 engine"></a>5.3.1 engine</h3><p>使用的存储引擎 建议都是用Innodb</p><h3 id="5-3-2-charset"><a href="#5-3-2-charset" class="headerlink" title="5.3.2 charset"></a>5.3.2 charset</h3><p>使用的字符集 这个参数也可以在列属性里设置,但是不建议这样做,整表设置相同字符集即可</p><p>常用的有:</p><ul><li>utf8 推荐使用** </li><li>utf8mb4 推荐使用***</li><li>gbk</li></ul><p>建议默认使用utf8mb4格式:</p><blockquote><p>MySQL在5.5.3之后增加了utf8mb4的编码，mb4即4-Byte UTF-8 Unicode Encoding，专门用来兼容四字节的unicode。utf8mb4为utf8的超集并兼容utf8，比utf8能表示更多的字符。</p><p>低版本的MySQL支持的utf8编码，最大字符长度为 3 字节，如果遇到 4 字节的字符就会出现错误了。</p><p>常见的四字节就是Emoji 表情（Emoji 是一种特殊的 Unicode 编码，常见于 ios 和 android 手机上），和一些不常用的汉字，以及任何新增的 Unicode 字符等等。</p></blockquote><h2 id="5-4-常用SQL分类"><a href="#5-4-常用SQL分类" class="headerlink" title="5.4 常用SQL分类"></a>5.4 常用SQL分类</h2><ul><li>DDL：数据定义语言</li><li>DML：数据操作语言</li><li>DCL：数据控制语言</li><li>DQL：数据的查询语言</li></ul><h2 id="5-5-DDL语句"><a href="#5-5-DDL语句" class="headerlink" title="5.5 DDL语句"></a>5.5 DDL语句</h2><h3 id="5-5-1-数据库操作"><a href="#5-5-1-数据库操作" class="headerlink" title="5.5.1 数据库操作"></a>5.5.1 数据库操作</h3><pre><code class="mysql"># 创建demo数据库mysql&gt; create database demo charset utf8mb4mysql&gt; create database if not exists demo charset utf8mb4;# 删除demo数据库mysql&gt; drop database demo;mysql&gt; drop database if exists demo;# 修改database字符集mysql&gt; alter database demo charset=utf8;</code></pre><h3 id="5-5-2-表操作"><a href="#5-5-2-表操作" class="headerlink" title="5.5.2 表操作"></a>5.5.2 表操作</h3><pre><code class="mysql"># 创建表CREATE TABLE `t_scrm_user_info`(  `id`          INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,  `user_id`     VARCHAR(32)      NOT NULL COMMENT &#39;用户ID作为唯一标示&#39;,  `user_name`   VARCHAR(32)      NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户姓名&#39;,  `user_sex`    TINYINT(3)       NOT NULL DEFAULT 0 COMMENT &#39;用户性别 0未知 1男 2女&#39;,  `user_mobile` VARCHAR(16)      NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户手机号&#39;,  `user_status` TINYINT(3)       NOT NULL DEFAULT 0 COMMENT &#39;用户状态 0正常 1锁定 -1删除&#39;,  `user_avatar` varchar(256)     NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户头像&#39;,  `create_time` DATETIME         NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  PRIMARY KEY (`id`),  UNIQUE KEY `UQ_USER_ID` (`user_id`)) ENGINE = InnoDB  DEFAULT CHARSET = utf8mb4 COMMENT =&#39;用户信息表&#39;;# 删除表mysql&gt; drop table t_scrm_user_info;# 重命名表mysql&gt; RENAME TABLE t_scrm_user_info to demo;# 复制表mysql&gt; CREATE table t_scrm_user_info like demo;# 清空表mysql&gt; truncate table t_scrm_user_info;# 添加列——添加update_time列ALTER TABLE t_scrm_user_info ADD update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;;# 添加列——在user_avatar列后添加user_remark列ALTER TABLE t_scrm_user_info ADD `user_remark` VARCHAR(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户备注&#39; AFTER user_avatar;# 更新列mysql&gt; ALTER TABLE t_scrm_user_info MODIFY user_name VARCHAR(64);注意上面语句更新的时候 会把user_name列上的其他属性更新没 如not null属性和comment属性所以建议写成如下：mysql&gt; ALTER TABLE t_scrm_user_info MODIFY user_name VARCHAR(32)      NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户姓名&#39;;# 更新列名mysql&gt; ALTER TABLE t_scrm_user_info CHANGE user_name u_name VARCHAR(32)      NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户姓名&#39;;# 删除列ALTER TABLE t_scrm_user_info DROP user_avatar;#添加索引ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。#删除索引DROP INDEX [indexName] ON mytable;</code></pre><h2 id="5-6-DML语句"><a href="#5-6-DML语句" class="headerlink" title="5.6 DML语句"></a>5.6 DML语句</h2><pre><code class="mysql"># 插入INSERT INTO t_scrm_user_info(user_id,user_name,user_sex,user_mobile,user_status) VALUES(&quot;123&quot;,&#39;nihao&#39;,1,&#39;18611111111&#39;,&#39;0&#39;),(&quot;345&quot;,&#39;hahah&#39;,1,&#39;18611111111&#39;,&#39;0&#39;);# 更新UPDATE t_scrm_user_info set user_id=&quot;444&quot; WHERE user_id=&quot;123&quot;;# 删除mysql&gt; DELETE FROM t_scrm_user_info where user_id =&quot;444&quot;;# 全表删除mysql&gt; DELETE FROM t_scrm_user_info;与truncate区别delete:         DML操作, 是逻辑性质删除,逐行进行删除,速度慢. 还在文件里 文件大小不会改变        主键继续原来的增长计数truncate:         DDL操作,对与表段中的数据页进行清空,速度快. 从文件里删除 文件大小改变        主键从1开始计数</code></pre><h2 id="5-7-DCL语句"><a href="#5-7-DCL语句" class="headerlink" title="5.7 DCL语句"></a>5.7 DCL语句</h2><pre><code class="mysql"># 管理用户通配符：%表示可以在任意主机使用用户登录数据库【注意】在mysql里面用户的定义为:用户名+主机名【注意】在mysql8.0中添加用户和授权必须是两步进行 不能用一条语句# 添加用户mysql&gt; CREATE USER &#39;read&#39;@&#39;10.15.2.%&#39; identified by &#39;123&#39;;# 删除用户mysql&gt; DROP USER &#39;read&#39;@&#39;10.15.2.%&#39;;#修改用户密码mysql&gt; set password for &#39;read&#39;@&#39;10.15.2.%&#39; = password(&#39;456&#39;);# 授权# 查看授权mysql&gt; show grants for &#39;read&#39;@&#39;10.15.2.%&#39;;+------------------------------------------+| Grants for read@10.15.2.%                |+------------------------------------------+| GRANT USAGE ON *.* TO &#39;read&#39;@&#39;10.15.2.%&#39; |+------------------------------------------+1 row in set (0.00 sec)# 添加授权grant 权限列表 on 数据库.表名  to  &#39;用户名&#39;@&#39;主机名&#39;;mysql&gt; GRANT CREATE,ALTER,DROP,INSERT,UPDATE,DELETE,SELECT ON demo.* TO &#39;read&#39;@&#39;10.15.2.%&#39;;# 授权所有权限mysql&gt; grant all privileges on demo.* to &#39;read&#39;@&#39;10.15.2.%&#39;;# 删除授权revoke 权限列表  on  数据库.表名  from  &#39;用户名&#39;@&#39;主机名&#39;;mysql&gt; revoke DROP,DELETE  on  demo.* from &#39;read&#39;@&#39;10.15.2.%&#39;;# 让授权生效FLUSH PRIVILEGES;</code></pre><h2 id="5-8-DQL语句"><a href="#5-8-DQL语句" class="headerlink" title="5.8 DQL语句"></a>5.8 DQL语句</h2><h3 id="5-8-1-SELECT"><a href="#5-8-1-SELECT" class="headerlink" title="5.8.1 SELECT"></a>5.8.1 SELECT</h3><pre><code class="mysql">SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMITa. select_expr    -- 可以用 * 表示所有字段。        select * from tb;    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）        select stu, 29+25, now() from tb;    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。        - 使用 as 关键字，也可省略 as.        select stu+10 as add10 from tb;b. FROM 子句    用于标识查询来源。    -- 可以为表起别名。使用as关键字。        SELECT * FROM tb1 AS tt, tb2 AS bb;    -- from子句后，可以同时出现多个表。        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。        SELECT * FROM tb1, tb2;    -- 向优化符提示如何选择索引        USE INDEX、IGNORE INDEX、FORCE INDEX        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;c. WHERE 子句    -- 从from获得的数据源中进行筛选。    -- 整型1表示真，0表示假。    -- 表达式由运算符和运算数组成。        -- 运算数：变量（字段）、值、函数返回值        -- 运算符：            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor            is/is not 加上ture/false/unknown，检验某个值的真假            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较d. GROUP BY 子句, 分组子句    GROUP BY 字段/别名 [排序方式]    分组后会进行排序。升序：ASC，降序：DESC    以下[合计函数]需配合 GROUP BY 使用：    count 返回不同的非NULL值数目  count(*)、count(字段)    sum 求和    max 求最大值    min 求最小值    avg 求平均值    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。e. HAVING 子句，条件子句    与 where 功能、用法相同，执行时机不同。    where 在开始时执行检测数据，对原数据进行过滤。    having 对筛选出的结果再次进行过滤。    having 字段必须是查询出来的，where 字段必须是数据表存在的。    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。    where 不可以使用合计函数。一般需用合计函数才会用 having    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。f. ORDER BY 子句，排序子句    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...    升序：ASC，降序：DESC    支持多个字段的排序。g. LIMIT 子句，限制结果数量子句    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。    limit 起始位置, 获取条数    省略第一个参数，表示从索引0开始。limit 获取条数h. DISTINCT, ALL 选项    distinct 去除重复记录    默认为 all, 全部记录</code></pre><h3 id="5-8-2-多表查询"><a href="#5-8-2-多表查询" class="headerlink" title="5.8.2 多表查询"></a>5.8.2 多表查询</h3><p>多表查询使用join关键字进行连接</p><p>连接方式分为四种:</p><ul><li>INNER JOIN：如果表中有至少一个匹配，则返回行</li><li>LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行</li><li>RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行</li><li>FULL JOIN：只要其中一个表中存在匹配，则返回行</li></ul><p>这里不详细介绍 看图理解</p><p><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/sql-join.png" alt=""></p><p>也可参考此篇<a href="https://www.runoob.com/sql/sql-join.html" target="_blank" rel="noopener">文档</a></p><h3 id="5-8-3-SHOW"><a href="#5-8-3-SHOW" class="headerlink" title="5.8.3 SHOW"></a>5.8.3 SHOW</h3><pre><code class="mysql">show  databases;                          #查看所有数据库show tables;                              #查看当前库的所有表SHOW TABLES FROM                          #查看某个指定库下的表show create database world                #查看建库语句show create table world.city              #查看建表语句show  grants for  root@&#39;localhost&#39;        #查看用户的权限信息show  charset；                            #查看字符集show collation                             #查看校对规则show processlist;                          #查看数据库连接情况show index from                            #表的索引情况show status                                 #数据库状态查看SHOW STATUS LIKE &#39;%lock%&#39;;                 #模糊查询数据库某些状态SHOW VARIABLES                             #查看所有配置信息SHOW variables LIKE &#39;%lock%&#39;;              #查看部分配置信息show engines                                #查看支持的所有的存储引擎show engine innodb status                  #查看InnoDB引擎相关的状态信息show binary logs                            #列举所有的二进制日志show master status                           #查看数据库的日志位置信息show binlog events;                          #查看二进制日志事件show slave status                           #查看从库状态SHOW RELAYLOG EVENTS                        #查看从库relaylog事件信息desc  (show colums from city)               #查看表的列定义信息</code></pre><h3 id="5-8-4其它关键字"><a href="#5-8-4其它关键字" class="headerlink" title="5.8.4其它关键字"></a>5.8.4其它关键字</h3><pre><code class="mysql"># distinct：去重复SELECT countrycode FROM city ;SELECT DISTINCT(countrycode) FROM city  ;# 联合查询- union allSELECT * FROM city WHERE countrycode IN (&#39;CHN&#39; ,&#39;USA&#39;);SELECT * FROM city WHERE countrycode=&#39;CHN&#39;UNION ALLSELECT * FROM city WHERE countrycode=&#39;USA&#39;# 联合查询- union SELECT * FROM city WHERE countrycode=&#39;CHN&#39;UNION SELECT * FROM city WHERE countrycode=&#39;USA&#39;说明:一般情况下,我们会将 IN 或者 OR 语句 改写成 UNION (ALL),来提高性能UNION     去重复UNION ALL 不去重复</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.Mysql安装及初始化</title>
      <link href="/2020/02/14/3-Mysql%E5%AE%89%E8%A3%85%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2020/02/14/3-Mysql%E5%AE%89%E8%A3%85%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>环境:Centos8 64位<br>版本:5.7.26 通用二级制版本<br>下载地址:   <a href="https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz" target="_blank" rel="noopener">https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz</a></p><h2 id="3-1-下载通用二进制包"><a href="#3-1-下载通用二进制包" class="headerlink" title="3.1 下载通用二进制包"></a>3.1 下载通用二进制包</h2><pre><code class="shell">[root@localhost Downloads]# wget  https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz</code></pre><h2 id="3-2-创建用户用户"><a href="#3-2-创建用户用户" class="headerlink" title="3.2 创建用户用户"></a>3.2 创建用户用户</h2><pre><code>[root@localhost ken]# useradd mysql</code></pre><h2 id="3-3-创建相应文件夹"><a href="#3-3-创建相应文件夹" class="headerlink" title="3.3 创建相应文件夹"></a>3.3 创建相应文件夹</h2><pre><code>#创建数据存放目录[root@localhost ken]# mkdir -p /data/3306#创建mysql程序存放的目录[root@localhost ken]# mkdir -p /app/database#创建日志存放的目录[root@localhost ken]# mkdir -p /log/3306</code></pre><h2 id="3-4-更改所属目录"><a href="#3-4-更改所属目录" class="headerlink" title="3.4 更改所属目录"></a>3.4 更改所属目录</h2><pre><code>[root@localhost ken]# chown -R mysql.mysql /data/3306  /app/database/ /log/3306/</code></pre><h2 id="3-5-解压mysql并放到指定目录"><a href="#3-5-解压mysql并放到指定目录" class="headerlink" title="3.5 解压mysql并放到指定目录"></a>3.5 解压mysql并放到指定目录</h2><pre><code>[ken@localhost Downloads]$ tar -zxvf mysql-5.7.26-linux-glibc2.12-i686.tar.gz [ken@localhost Downloads]$ lsmysql-5.7.26-linux-glibc2.12-i686  mysql-5.7.26-linux-glibc2.12-i686.tar.gz[ken@localhost Downloads]$ sudo mv mysql-5.7.26-linux-glibc2.12-i686 /app/database/mysql[ken@localhost Downloads]$ sudo chown -R mysql.mysql /app/database/mysql</code></pre><h2 id="3-6设置环境变量"><a href="#3-6设置环境变量" class="headerlink" title="3.6设置环境变量"></a>3.6设置环境变量</h2><pre><code>[ken@localhost ~]$ suPassword: [root@localhost ken]# echo &quot;export PATH=/app/database/mysql/bin:$PATH&quot; &gt;&gt; /etc/profile[root@localhost ken]# exitexit[ken@localhost ~]$ source /etc/profile#显示以下内容即可完成此安装步骤[ken@localhost bin]$ mysql -Vmysql  Ver 14.14 Distrib 5.7.26, for linux-glibc2.12 (x86_64) using  EditLine wrapper【注意】在centos8中 经常会报libncurses.so.5这个文件不存在 但是已经安装了libncurses库还是有报错的话主要是再ceontos中有它的升级版文件/lib64/libncurses.so.6.1 我们做一个软连接即可ln -s /lib64/libncurses.so.6.1 /lib64/libncurses.so.5</code></pre><h2 id="3-7-初始化Mysql"><a href="#3-7-初始化Mysql" class="headerlink" title="3.7 初始化Mysql"></a>3.7 初始化Mysql</h2><pre><code>[root@localhost ken]# mysqld --initialize-insecure --user=mysql --basedir=/app/database/mysql --datadir=/data/3306</code></pre><h2 id="3-8-配置文件设置"><a href="#3-8-配置文件设置" class="headerlink" title="3.8 配置文件设置"></a>3.8 配置文件设置</h2><pre><code>cat &gt; /etc/my.cnf &lt;&lt;EOF[mysqld]user=mysqlbasedir=/app/database/mysqldatadir=/data/3306socket=/tmp/mysql3306.sock[mysql]socket=/tmp/mysql3306.sockEOF</code></pre><h2 id="3-9-准备Mysql启动脚本"><a href="#3-9-准备Mysql启动脚本" class="headerlink" title="3.9 准备Mysql启动脚本"></a>3.9 准备Mysql启动脚本</h2><pre><code>root@localhost support-files]# pwd/app/database/mysql/support-files[root@localhost support-files]# cp mysql.server /etc/init.d/mysqld[root@localhost support-files]# service mysqld startStarting MySQL. SUCCESS! </code></pre><h2 id="3-10-验证是否可以连接成功"><a href="#3-10-验证是否可以连接成功" class="headerlink" title="3.10 验证是否可以连接成功"></a>3.10 验证是否可以连接成功</h2><pre><code>[root@localhost support-files]# mysqlWelcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.26 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; </code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.Mysql产品线</title>
      <link href="/2020/02/13/2-Mysql%E4%BA%A7%E5%93%81%E7%BA%BF/"/>
      <url>/2020/02/13/2-Mysql%E4%BA%A7%E5%93%81%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-Mysql主流厂家"><a href="#2-1-Mysql主流厂家" class="headerlink" title="2.1 Mysql主流厂家"></a>2.1 Mysql主流厂家</h2><ul><li>Oracle:MySQL官方版</li><li>红帽 :MariaDB</li><li>Percona: PerconaDB</li><li>阿里云做的也很好</li></ul><h2 id="2-2-Mysql主流版本"><a href="#2-2-Mysql主流版本" class="headerlink" title="2.2 Mysql主流版本"></a>2.2 Mysql主流版本</h2><ul><li>5.6—–5.6.36 5.6.38 5.6.40 5.6.46</li><li>5.7—–5.7.20 5.7.22 5.7.24 5.7.28</li><li>8.0—–8.0.11</li></ul><p><code>建议选择GA稳定版下半年发布的产品</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.数据库分类</title>
      <link href="/2020/02/12/1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%B1%BB/"/>
      <url>/2020/02/12/1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>我们可以从 <a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">https://db-engines.com/en/ranking</a>  这个网站查看数据库在互联网上的<code>流行程度</code>:<br><img src="http://mysql317.oss-cn-beijing.aliyuncs.com/database.png" alt="数据库流行程度"></p><h2 id="1-1-关系型数据库"><a href="#1-1-关系型数据库" class="headerlink" title="1.1 关系型数据库"></a>1.1 关系型数据库</h2><p>英文简称为RDMS,最常见的数据库,其核心思想是将复杂的数据结构归结成简单的二元关系<br>常见的关系型数据库为:Mysql,SqlServer,Oracle</p><h2 id="1-2-键值存储数据库"><a href="#1-2-键值存储数据库" class="headerlink" title="1.2  键值存储数据库"></a>1.2  键值存储数据库</h2><p>键值数据库是一种非关系数据库，它使用简单的键值方法来存储数据<br>键值数据库将数据存储为键值对集合，其中键作为唯一标识符<br>常见的键值存储数据库为：Redis和memcached</p><h2 id="1-3-列存储数据库"><a href="#1-3-列存储数据库" class="headerlink" title="1.3 列存储数据库"></a>1.3 列存储数据库</h2><p>列式存储(column-based)是相对于传统关系型数据库的行式存储(Row-basedstorage)来说的<br>简单来说两者的区别就是对表中数据的存储形式的差异<br>常见的列存储数据库为：HBase</p><h2 id="1-4-面向文档数据库"><a href="#1-4-面向文档数据库" class="headerlink" title="1.4 面向文档数据库"></a>1.4 面向文档数据库</h2><p>此类数据库可存放并获取文档，可以是XML、JSON、BSON等格式，这些文档具备可述性（self-describing），呈现分层的树状结构（hierarchical tree data structure），可以包含映射表、集合和纯量值。数据库中的文档彼此相似，但不必完全相同。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。文档数据库可视为其值可查的键值数据库。<br>常见的面向文档数据库为：MongoDB</p><h2 id="1-5-图形数据库"><a href="#1-5-图形数据库" class="headerlink" title="1.5 图形数据库"></a>1.5 图形数据库</h2><p>故名思意就是存储图形关系的数据库,也是Nosql的一种<br>常见的图形数据库为:Neo4J、ArangoDB、OrientDB、FlockDB、GraphDB、InfiniteGraph、Titan和Cayley等</p><h2 id="1-6-搜索引擎存储"><a href="#1-6-搜索引擎存储" class="headerlink" title="1.6 搜索引擎存储"></a>1.6 搜索引擎存储</h2><p>搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。<br>常见的搜索引擎存储为:Elasticsearch,solr</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
